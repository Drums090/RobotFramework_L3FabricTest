<?xml version="1.0" encoding="UTF-8"?>
<robot rpa="false" generated="20181224 22:34:11.896" generator="Robot 3.1 (Python 2.7.10 on darwin)">
<suite source="/Users/bg/PycharmProjects/L3FabricTest/Tests/L3FabricTest.robot" id="s1" name="L3FabricTest">
<kw type="setup" name="Connect To Switches" library="Common">
<doc>Establish connection to a switch which gets used by test cases.</doc>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>List value is ${spines}</arg>
</arguments>
<msg timestamp="20181224 22:34:11.985" level="INFO">List value is {'DCA-Spine1': {'p2p_ping': ['10.101.201.1', '10.101.202.1', '10.101.203.1', '10.101.204.1'], 'management_ip': '10.255.255.101', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'loopback': '1.1.1.101'}, 'DCA-Spine2': {'p2p_ping': ['10.102.201.1', '10.102.202.1', '10.102.203.1', '10.102.204.1'], 'management_ip': '10.255.255.102', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'loopback': '1.1.1.102'}}</msg>
<status status="PASS" endtime="20181224 22:34:11.986" starttime="20181224 22:34:11.985"></status>
</kw>
<kw type="for" name="${spine} IN [ @{spines} ]">
<kw type="foritem" name="${spine} = DCA-Spine1">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<msg timestamp="20181224 22:34:11.986" level="INFO">DCA-Spine1</msg>
<status status="PASS" endtime="20181224 22:34:11.986" starttime="20181224 22:34:11.986"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${spines}</arg>
<arg>${spine}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:11.987" level="INFO">${target_dictionary} = {'p2p_ping': ['10.101.201.1', '10.101.202.1', '10.101.203.1', '10.101.204.1'], 'management_ip': '10.255.255.101', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ...</msg>
<status status="PASS" endtime="20181224 22:34:11.987" starttime="20181224 22:34:11.986"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<msg timestamp="20181224 22:34:11.987" level="INFO">{'p2p_ping': ['10.101.201.1', '10.101.202.1', '10.101.203.1', '10.101.204.1'], 'management_ip': '10.255.255.101', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'loopback': '1.1.1.101'}</msg>
<status status="PASS" endtime="20181224 22:34:11.987" starttime="20181224 22:34:11.987"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>management_ip</arg>
</arguments>
<assign>
<var>${host}</var>
</assign>
<msg timestamp="20181224 22:34:11.987" level="INFO">${host} = 10.255.255.101</msg>
<status status="PASS" endtime="20181224 22:34:11.987" starttime="20181224 22:34:11.987"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<msg timestamp="20181224 22:34:11.988" level="INFO">10.255.255.101</msg>
<status status="PASS" endtime="20181224 22:34:11.988" starttime="20181224 22:34:11.988"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Connect To</arg>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${spine}</arg>
</arguments>
<kw name="Connect To" library="AristaLibrary">
<doc>This is the cornerstone of all testing. The Connect To
keyword accepts the necessary parameters to setup an API connection to
your node.</doc>
<arguments>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${spine}</arg>
</arguments>
<msg timestamp="20181224 22:34:12.542" level="INFO">Created connection to https://admin:****@10.255.255.101:443/command-api: model: vEOS, serial: , systemMAC: 00:0c:29:3f:60:5d, version: 4.21.2F, lastBootTime: 1544516608.0</msg>
<status status="PASS" endtime="20181224 22:34:12.542" starttime="20181224 22:34:11.988"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:12.542" starttime="20181224 22:34:11.988"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:12.543" starttime="20181224 22:34:11.986"></status>
</kw>
<kw type="foritem" name="${spine} = DCA-Spine2">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<msg timestamp="20181224 22:34:12.543" level="INFO">DCA-Spine2</msg>
<status status="PASS" endtime="20181224 22:34:12.544" starttime="20181224 22:34:12.543"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${spines}</arg>
<arg>${spine}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:12.544" level="INFO">${target_dictionary} = {'p2p_ping': ['10.102.201.1', '10.102.202.1', '10.102.203.1', '10.102.204.1'], 'management_ip': '10.255.255.102', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ...</msg>
<status status="PASS" endtime="20181224 22:34:12.544" starttime="20181224 22:34:12.544"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<msg timestamp="20181224 22:34:12.545" level="INFO">{'p2p_ping': ['10.102.201.1', '10.102.202.1', '10.102.203.1', '10.102.204.1'], 'management_ip': '10.255.255.102', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'loopback': '1.1.1.102'}</msg>
<status status="PASS" endtime="20181224 22:34:12.545" starttime="20181224 22:34:12.545"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>management_ip</arg>
</arguments>
<assign>
<var>${host}</var>
</assign>
<msg timestamp="20181224 22:34:12.546" level="INFO">${host} = 10.255.255.102</msg>
<status status="PASS" endtime="20181224 22:34:12.546" starttime="20181224 22:34:12.545"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<msg timestamp="20181224 22:34:12.546" level="INFO">10.255.255.102</msg>
<status status="PASS" endtime="20181224 22:34:12.546" starttime="20181224 22:34:12.546"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Connect To</arg>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${spine}</arg>
</arguments>
<kw name="Connect To" library="AristaLibrary">
<doc>This is the cornerstone of all testing. The Connect To
keyword accepts the necessary parameters to setup an API connection to
your node.</doc>
<arguments>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${spine}</arg>
</arguments>
<msg timestamp="20181224 22:34:13.157" level="INFO">Created connection to https://admin:****@10.255.255.102:443/command-api: model: vEOS, serial: , systemMAC: 00:0c:29:0b:9f:28, version: 4.21.2F, lastBootTime: 1544516629.0</msg>
<status status="PASS" endtime="20181224 22:34:13.157" starttime="20181224 22:34:12.547"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:13.157" starttime="20181224 22:34:12.546"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:13.157" starttime="20181224 22:34:12.543"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:13.157" starttime="20181224 22:34:11.986"></status>
</kw>
<kw type="for" name="${leaf} IN [ @{leafs} ]">
<kw type="foritem" name="${leaf} = DCA-BL2">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:13.158" level="INFO">DCA-BL2</msg>
<status status="PASS" endtime="20181224 22:34:13.158" starttime="20181224 22:34:13.158"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:13.159" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.204', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.203'], 'loopback': '1.1.1.204'}</msg>
<status status="PASS" endtime="20181224 22:34:13.159" starttime="20181224 22:34:13.158"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<msg timestamp="20181224 22:34:13.159" level="INFO">{'management_ip': '10.255.255.204', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.203'], 'loopback': '1.1.1.204'}</msg>
<status status="PASS" endtime="20181224 22:34:13.159" starttime="20181224 22:34:13.159"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>management_ip</arg>
</arguments>
<assign>
<var>${host}</var>
</assign>
<msg timestamp="20181224 22:34:13.160" level="INFO">${host} = 10.255.255.204</msg>
<status status="PASS" endtime="20181224 22:34:13.160" starttime="20181224 22:34:13.160"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<msg timestamp="20181224 22:34:13.160" level="INFO">10.255.255.204</msg>
<status status="PASS" endtime="20181224 22:34:13.160" starttime="20181224 22:34:13.160"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Connect To</arg>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${leaf}</arg>
</arguments>
<kw name="Connect To" library="AristaLibrary">
<doc>This is the cornerstone of all testing. The Connect To
keyword accepts the necessary parameters to setup an API connection to
your node.</doc>
<arguments>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:13.742" level="INFO">Created connection to https://admin:****@10.255.255.204:443/command-api: model: vEOS, serial: , systemMAC: 00:0c:29:56:ef:fa, version: 4.21.2F, lastBootTime: 1544516583.0</msg>
<status status="PASS" endtime="20181224 22:34:13.742" starttime="20181224 22:34:13.161"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:13.742" starttime="20181224 22:34:13.161"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:13.742" starttime="20181224 22:34:13.158"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-BL1">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:13.743" level="INFO">DCA-BL1</msg>
<status status="PASS" endtime="20181224 22:34:13.743" starttime="20181224 22:34:13.743"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:13.744" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.203', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.204'], 'loopback': '1.1.1.203'}</msg>
<status status="PASS" endtime="20181224 22:34:13.744" starttime="20181224 22:34:13.744"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<msg timestamp="20181224 22:34:13.745" level="INFO">{'management_ip': '10.255.255.203', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.204'], 'loopback': '1.1.1.203'}</msg>
<status status="PASS" endtime="20181224 22:34:13.745" starttime="20181224 22:34:13.744"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>management_ip</arg>
</arguments>
<assign>
<var>${host}</var>
</assign>
<msg timestamp="20181224 22:34:13.745" level="INFO">${host} = 10.255.255.203</msg>
<status status="PASS" endtime="20181224 22:34:13.745" starttime="20181224 22:34:13.745"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<msg timestamp="20181224 22:34:13.746" level="INFO">10.255.255.203</msg>
<status status="PASS" endtime="20181224 22:34:13.746" starttime="20181224 22:34:13.746"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Connect To</arg>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${leaf}</arg>
</arguments>
<kw name="Connect To" library="AristaLibrary">
<doc>This is the cornerstone of all testing. The Connect To
keyword accepts the necessary parameters to setup an API connection to
your node.</doc>
<arguments>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:14.363" level="INFO">Created connection to https://admin:****@10.255.255.203:443/command-api: model: vEOS, serial: , systemMAC: 00:0c:29:02:e6:de, version: 4.21.2F, lastBootTime: 1544516581.0</msg>
<status status="PASS" endtime="20181224 22:34:14.363" starttime="20181224 22:34:13.747"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:14.363" starttime="20181224 22:34:13.746"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:14.363" starttime="20181224 22:34:13.742"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-Leaf2">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:14.364" level="INFO">DCA-Leaf2</msg>
<status status="PASS" endtime="20181224 22:34:14.364" starttime="20181224 22:34:14.363"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:14.365" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.202', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.201'], 'loopback': '1.1.1.202'}</msg>
<status status="PASS" endtime="20181224 22:34:14.365" starttime="20181224 22:34:14.364"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<msg timestamp="20181224 22:34:14.365" level="INFO">{'management_ip': '10.255.255.202', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.201'], 'loopback': '1.1.1.202'}</msg>
<status status="PASS" endtime="20181224 22:34:14.366" starttime="20181224 22:34:14.365"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>management_ip</arg>
</arguments>
<assign>
<var>${host}</var>
</assign>
<msg timestamp="20181224 22:34:14.366" level="INFO">${host} = 10.255.255.202</msg>
<status status="PASS" endtime="20181224 22:34:14.366" starttime="20181224 22:34:14.366"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<msg timestamp="20181224 22:34:14.367" level="INFO">10.255.255.202</msg>
<status status="PASS" endtime="20181224 22:34:14.367" starttime="20181224 22:34:14.366"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Connect To</arg>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${leaf}</arg>
</arguments>
<kw name="Connect To" library="AristaLibrary">
<doc>This is the cornerstone of all testing. The Connect To
keyword accepts the necessary parameters to setup an API connection to
your node.</doc>
<arguments>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:15.012" level="INFO">Created connection to https://admin:****@10.255.255.202:443/command-api: model: vEOS, serial: , systemMAC: 00:0c:29:9a:c1:e7, version: 4.21.2F, lastBootTime: 1543542657.0</msg>
<status status="PASS" endtime="20181224 22:34:15.012" starttime="20181224 22:34:14.367"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:15.013" starttime="20181224 22:34:14.367"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:15.013" starttime="20181224 22:34:14.363"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-Leaf1">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:15.013" level="INFO">DCA-Leaf1</msg>
<status status="PASS" endtime="20181224 22:34:15.014" starttime="20181224 22:34:15.013"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:15.014" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.201', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.202'], 'loopback': '1.1.1.201'}</msg>
<status status="PASS" endtime="20181224 22:34:15.014" starttime="20181224 22:34:15.014"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<msg timestamp="20181224 22:34:15.015" level="INFO">{'management_ip': '10.255.255.201', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.202'], 'loopback': '1.1.1.201'}</msg>
<status status="PASS" endtime="20181224 22:34:15.015" starttime="20181224 22:34:15.015"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>management_ip</arg>
</arguments>
<assign>
<var>${host}</var>
</assign>
<msg timestamp="20181224 22:34:15.016" level="INFO">${host} = 10.255.255.201</msg>
<status status="PASS" endtime="20181224 22:34:15.016" starttime="20181224 22:34:15.015"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${host}</arg>
</arguments>
<msg timestamp="20181224 22:34:15.016" level="INFO">10.255.255.201</msg>
<status status="PASS" endtime="20181224 22:34:15.016" starttime="20181224 22:34:15.016"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Connect To</arg>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${leaf}</arg>
</arguments>
<kw name="Connect To" library="AristaLibrary">
<doc>This is the cornerstone of all testing. The Connect To
keyword accepts the necessary parameters to setup an API connection to
your node.</doc>
<arguments>
<arg>host=${host}</arg>
<arg>transport=${TRANSPORT}</arg>
<arg>username=${USERNAME}</arg>
<arg>password=${PASSWORD}</arg>
<arg>port=${PORT}</arg>
<arg>alias=${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:15.708" level="INFO">Created connection to https://admin:****@10.255.255.201:443/command-api: model: vEOS, serial: , systemMAC: 00:0c:29:3f:f6:6c, version: 4.21.2F, lastBootTime: 1543542658.0</msg>
<status status="PASS" endtime="20181224 22:34:15.708" starttime="20181224 22:34:15.017"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:15.709" starttime="20181224 22:34:15.016"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:15.709" starttime="20181224 22:34:15.013"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:15.709" starttime="20181224 22:34:13.158"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:15.709" starttime="20181224 22:34:11.985"></status>
</kw>
<test id="s1-t1" name="Spine Ping Tests">
<kw type="for" name="${spine} IN [ @{spines} ]">
<kw type="foritem" name="${spine} = DCA-Spine1">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:15.711" starttime="20181224 22:34:15.710"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:34:15.711" level="INFO">${switch_info} = {'username': 'admin', 'index': 1, 'node': Node(connection=EapiConnection(transport=https://10.255.255.101:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine1', 'host': '10.255.255.101', 'tra...</msg>
<status status="PASS" endtime="20181224 22:34:15.711" starttime="20181224 22:34:15.711"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:34:15.712" level="INFO">{'username': 'admin', 'index': 1, 'node': Node(connection=EapiConnection(transport=https://10.255.255.101:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine1', 'host': '10.255.255.101', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.101:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:34:15.712" starttime="20181224 22:34:15.712"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<msg timestamp="20181224 22:34:15.713" level="INFO">DCA-Spine1</msg>
<status status="PASS" endtime="20181224 22:34:15.713" starttime="20181224 22:34:15.712"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${spines}</arg>
<arg>${spine}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:15.713" level="INFO">${target_dictionary} = {'p2p_ping': ['10.101.201.1', '10.101.202.1', '10.101.203.1', '10.101.204.1'], 'management_ip': '10.255.255.101', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ...</msg>
<status status="PASS" endtime="20181224 22:34:15.713" starttime="20181224 22:34:15.713"></status>
</kw>
<kw name="Initiate All Spine Ping Tests" library="Ping_All">
<doc>Running all Ping Tests on Spines</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<kw name="Ping Spine P2Ps" library="Ping_P2Ps">
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>p2p_ping</arg>
</arguments>
<assign>
<var>@{p2ps}</var>
</assign>
<msg timestamp="20181224 22:34:15.715" level="INFO">@{p2ps} = [ 10.101.201.1 | 10.101.202.1 | 10.101.203.1 | 10.101.204.1 ]</msg>
<status status="PASS" endtime="20181224 22:34:15.715" starttime="20181224 22:34:15.715"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<msg timestamp="20181224 22:34:15.715" level="INFO">{'p2p_ping': ['10.101.201.1', '10.101.202.1', '10.101.203.1', '10.101.204.1'], 'management_ip': '10.255.255.101', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'loopback': '1.1.1.101'}</msg>
<status status="PASS" endtime="20181224 22:34:15.716" starttime="20181224 22:34:15.715"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${p2ps}</arg>
</arguments>
<msg timestamp="20181224 22:34:15.716" level="INFO">['10.101.201.1', '10.101.202.1', '10.101.203.1', '10.101.204.1']</msg>
<status status="PASS" endtime="20181224 22:34:15.716" starttime="20181224 22:34:15.716"></status>
</kw>
<kw type="for" name="${ip} IN [ @{p2ps} ]">
<kw type="foritem" name="${ip} = 10.101.201.1">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${ip}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${ip}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:16.477" level="INFO">${output} = [{'command': 'ping 10.101.201.1', 'result': {u'messages': [u'PING 10.101.201.1 (10.101.201.1) 72(100) bytes of data.\n80 bytes from 10.101.201.1: icmp_seq=1 ttl=64 time=169 ms\n80 bytes from 10.101.20...</msg>
<status status="PASS" endtime="20181224 22:34:16.477" starttime="20181224 22:34:15.717"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:16.478" level="INFO">${result} = {u'messages': [u'PING 10.101.201.1 (10.101.201.1) 72(100) bytes of data.\n80 bytes from 10.101.201.1: icmp_seq=1 ttl=64 time=169 ms\n80 bytes from 10.101.201.1: icmp_seq=2 ttl=64 time=174 ms\n80 bytes...</msg>
<status status="PASS" endtime="20181224 22:34:16.478" starttime="20181224 22:34:16.477"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:16.479" level="INFO">{u'messages': [u'PING 10.101.201.1 (10.101.201.1) 72(100) bytes of data.\n80 bytes from 10.101.201.1: icmp_seq=1 ttl=64 time=169 ms\n80 bytes from 10.101.201.1: icmp_seq=2 ttl=64 time=174 ms\n80 bytes from 10.101.201.1: icmp_seq=3 ttl=64 time=187 ms\n80 bytes from 10.101.201.1: icmp_seq=4 ttl=64 time=201 ms\n80 bytes from 10.101.201.1: icmp_seq=5 ttl=64 time=213 ms\n\n--- 10.101.201.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 47ms\nrtt min/avg/max/mdev = 169.111/189.184/213.453/16.578 ms, pipe 5, ipg/ewma 11.888/180.399 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:16.479" starttime="20181224 22:34:16.478"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:16.480" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:16.480" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:16.480" starttime="20181224 22:34:16.479"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:16.481" starttime="20181224 22:34:16.480"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:16.481" starttime="20181224 22:34:15.717"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:16.481" starttime="20181224 22:34:15.716"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:16.481" starttime="20181224 22:34:15.716"></status>
</kw>
<kw type="foritem" name="${ip} = 10.101.202.1">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${ip}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${ip}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:17.277" level="INFO">${output} = [{'command': 'ping 10.101.202.1', 'result': {u'messages': [u'PING 10.101.202.1 (10.101.202.1) 72(100) bytes of data.\n80 bytes from 10.101.202.1: icmp_seq=1 ttl=64 time=182 ms\n80 bytes from 10.101.20...</msg>
<status status="PASS" endtime="20181224 22:34:17.277" starttime="20181224 22:34:16.482"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:17.278" level="INFO">${result} = {u'messages': [u'PING 10.101.202.1 (10.101.202.1) 72(100) bytes of data.\n80 bytes from 10.101.202.1: icmp_seq=1 ttl=64 time=182 ms\n80 bytes from 10.101.202.1: icmp_seq=2 ttl=64 time=189 ms\n80 bytes...</msg>
<status status="PASS" endtime="20181224 22:34:17.278" starttime="20181224 22:34:17.277"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:17.278" level="INFO">{u'messages': [u'PING 10.101.202.1 (10.101.202.1) 72(100) bytes of data.\n80 bytes from 10.101.202.1: icmp_seq=1 ttl=64 time=182 ms\n80 bytes from 10.101.202.1: icmp_seq=2 ttl=64 time=189 ms\n80 bytes from 10.101.202.1: icmp_seq=3 ttl=64 time=203 ms\n80 bytes from 10.101.202.1: icmp_seq=4 ttl=64 time=215 ms\n80 bytes from 10.101.202.1: icmp_seq=5 ttl=64 time=229 ms\n\n--- 10.101.202.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 47ms\nrtt min/avg/max/mdev = 182.452/204.034/229.379/17.089 ms, pipe 5, ipg/ewma 11.824/194.526 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:17.279" starttime="20181224 22:34:17.278"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:17.279" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:17.279" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:17.280" starttime="20181224 22:34:17.279"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:17.280" starttime="20181224 22:34:17.280"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:17.280" starttime="20181224 22:34:16.482"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:17.280" starttime="20181224 22:34:16.481"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:17.280" starttime="20181224 22:34:16.481"></status>
</kw>
<kw type="foritem" name="${ip} = 10.101.203.1">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${ip}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${ip}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:18.105" level="INFO">${output} = [{'command': 'ping 10.101.203.1', 'result': {u'messages': [u'PING 10.101.203.1 (10.101.203.1) 72(100) bytes of data.\n80 bytes from 10.101.203.1: icmp_seq=1 ttl=64 time=174 ms\n80 bytes from 10.101.20...</msg>
<status status="PASS" endtime="20181224 22:34:18.105" starttime="20181224 22:34:17.282"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:18.106" level="INFO">${result} = {u'messages': [u'PING 10.101.203.1 (10.101.203.1) 72(100) bytes of data.\n80 bytes from 10.101.203.1: icmp_seq=1 ttl=64 time=174 ms\n80 bytes from 10.101.203.1: icmp_seq=2 ttl=64 time=179 ms\n80 bytes...</msg>
<status status="PASS" endtime="20181224 22:34:18.106" starttime="20181224 22:34:18.106"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:18.107" level="INFO">{u'messages': [u'PING 10.101.203.1 (10.101.203.1) 72(100) bytes of data.\n80 bytes from 10.101.203.1: icmp_seq=1 ttl=64 time=174 ms\n80 bytes from 10.101.203.1: icmp_seq=2 ttl=64 time=179 ms\n80 bytes from 10.101.203.1: icmp_seq=3 ttl=64 time=192 ms\n80 bytes from 10.101.203.1: icmp_seq=4 ttl=64 time=206 ms\n80 bytes from 10.101.203.1: icmp_seq=5 ttl=64 time=217 ms\n\n--- 10.101.203.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 47ms\nrtt min/avg/max/mdev = 174.278/194.158/217.637/16.138 ms, pipe 5, ipg/ewma 11.895/185.433 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:18.107" starttime="20181224 22:34:18.107"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:18.108" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:18.108" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:18.108" starttime="20181224 22:34:18.107"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:18.109" starttime="20181224 22:34:18.108"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:18.109" starttime="20181224 22:34:17.281"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:18.109" starttime="20181224 22:34:17.281"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:18.109" starttime="20181224 22:34:17.281"></status>
</kw>
<kw type="foritem" name="${ip} = 10.101.204.1">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${ip}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${ip}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:18.903" level="INFO">${output} = [{'command': 'ping 10.101.204.1', 'result': {u'messages': [u'PING 10.101.204.1 (10.101.204.1) 72(100) bytes of data.\n80 bytes from 10.101.204.1: icmp_seq=1 ttl=64 time=220 ms\n80 bytes from 10.101.20...</msg>
<status status="PASS" endtime="20181224 22:34:18.903" starttime="20181224 22:34:18.110"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:18.904" level="INFO">${result} = {u'messages': [u'PING 10.101.204.1 (10.101.204.1) 72(100) bytes of data.\n80 bytes from 10.101.204.1: icmp_seq=1 ttl=64 time=220 ms\n80 bytes from 10.101.204.1: icmp_seq=2 ttl=64 time=225 ms\n80 bytes...</msg>
<status status="PASS" endtime="20181224 22:34:18.904" starttime="20181224 22:34:18.904"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:18.905" level="INFO">{u'messages': [u'PING 10.101.204.1 (10.101.204.1) 72(100) bytes of data.\n80 bytes from 10.101.204.1: icmp_seq=1 ttl=64 time=220 ms\n80 bytes from 10.101.204.1: icmp_seq=2 ttl=64 time=225 ms\n80 bytes from 10.101.204.1: icmp_seq=3 ttl=64 time=236 ms\n80 bytes from 10.101.204.1: icmp_seq=4 ttl=64 time=247 ms\n80 bytes from 10.101.204.1: icmp_seq=5 ttl=64 time=260 ms\n\n--- 10.101.204.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 47ms\nrtt min/avg/max/mdev = 220.658/238.230/260.851/14.775 ms, pipe 5, ipg/ewma 11.964/230.565 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:18.905" starttime="20181224 22:34:18.905"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:18.906" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:18.906" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:18.906" starttime="20181224 22:34:18.906"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:18.907" starttime="20181224 22:34:18.906"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:18.907" starttime="20181224 22:34:18.110"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:18.907" starttime="20181224 22:34:18.109"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:18.907" starttime="20181224 22:34:18.109"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:18.907" starttime="20181224 22:34:15.716"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:18.907" starttime="20181224 22:34:15.714"></status>
</kw>
<kw name="Ping Spine Loopbacks" library="Ping_Loopbacks">
<kw type="for" name="${loopback} IN [ @{loopback_ping} ]">
<kw type="foritem" name="${loopback} = 1.1.1.101">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:18.909" level="INFO">1.1.1.101</msg>
<status status="PASS" endtime="20181224 22:34:18.909" starttime="20181224 22:34:18.908"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:19.401" level="INFO">${output} = [{'command': 'ping 1.1.1.101', 'result': {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=0.069 ms\n80 bytes from 1.1.1.101: icmp_seq...</msg>
<status status="PASS" endtime="20181224 22:34:19.401" starttime="20181224 22:34:18.910"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:19.402" level="INFO">${result} = {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=0.069 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=64 time=0.030 ms\n80 bytes from 1....</msg>
<status status="PASS" endtime="20181224 22:34:19.402" starttime="20181224 22:34:19.402"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:19.403" level="INFO">{u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=0.069 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=64 time=0.030 ms\n80 bytes from 1.1.1.101: icmp_seq=3 ttl=64 time=0.025 ms\n80 bytes from 1.1.1.101: icmp_seq=4 ttl=64 time=0.024 ms\n80 bytes from 1.1.1.101: icmp_seq=5 ttl=64 time=0.023 ms\n\n--- 1.1.1.101 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.023/0.034/0.069/0.017 ms, ipg/ewma 0.074/0.051 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:19.403" starttime="20181224 22:34:19.403"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:19.404" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:19.404" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:19.404" starttime="20181224 22:34:19.403"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:19.405" starttime="20181224 22:34:19.404"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:19.405" starttime="20181224 22:34:18.909"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:19.405" starttime="20181224 22:34:18.909"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:19.405" starttime="20181224 22:34:18.908"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.102">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:19.406" level="INFO">1.1.1.102</msg>
<status status="PASS" endtime="20181224 22:34:19.406" starttime="20181224 22:34:19.405"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:20.440" level="INFO">${output} = [{'command': 'ping 1.1.1.102', 'result': {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=63 time=464 ms\n80 bytes from 1.1.1.102: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:20.440" starttime="20181224 22:34:19.407"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:20.441" level="INFO">${result} = {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=63 time=464 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=63 time=470 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:20.441" starttime="20181224 22:34:20.440"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:20.442" level="INFO">{u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=63 time=464 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=63 time=470 ms\n80 bytes from 1.1.1.102: icmp_seq=3 ttl=63 time=482 ms\n80 bytes from 1.1.1.102: icmp_seq=4 ttl=63 time=498 ms\n80 bytes from 1.1.1.102: icmp_seq=5 ttl=63 time=509 ms\n\n--- 1.1.1.102 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 464.556/485.241/509.941/16.952 ms, pipe 5, ipg/ewma 11.748/476.175 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:20.442" starttime="20181224 22:34:20.441"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:20.443" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:20.443" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:20.443" starttime="20181224 22:34:20.442"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:20.444" starttime="20181224 22:34:20.443"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:20.444" starttime="20181224 22:34:19.406"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:20.444" starttime="20181224 22:34:19.406"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:20.444" starttime="20181224 22:34:19.405"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.201">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:20.444" level="INFO">1.1.1.201</msg>
<status status="PASS" endtime="20181224 22:34:20.444" starttime="20181224 22:34:20.444"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:21.280" level="INFO">${output} = [{'command': 'ping 1.1.1.201', 'result': {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=204 ms\n80 bytes from 1.1.1.201: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:21.280" starttime="20181224 22:34:20.446"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:21.281" level="INFO">${result} = {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=204 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=64 time=214 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:21.281" starttime="20181224 22:34:21.281"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:21.282" level="INFO">{u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=204 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=64 time=214 ms\n80 bytes from 1.1.1.201: icmp_seq=3 ttl=64 time=228 ms\n80 bytes from 1.1.1.201: icmp_seq=4 ttl=64 time=241 ms\n80 bytes from 1.1.1.201: icmp_seq=5 ttl=64 time=253 ms\n\n--- 1.1.1.201 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 204.008/228.133/253.195/17.702 ms, pipe 5, ipg/ewma 11.631/217.375 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:21.282" starttime="20181224 22:34:21.282"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:21.283" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:21.283" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:21.283" starttime="20181224 22:34:21.282"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:21.284" starttime="20181224 22:34:21.283"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:21.284" starttime="20181224 22:34:20.445"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:21.284" starttime="20181224 22:34:20.445"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:21.284" starttime="20181224 22:34:20.444"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.202">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:21.285" level="INFO">1.1.1.202</msg>
<status status="PASS" endtime="20181224 22:34:21.285" starttime="20181224 22:34:21.284"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:22.084" level="INFO">${output} = [{'command': 'ping 1.1.1.202', 'result': {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 1.1.1.202: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:22.084" starttime="20181224 22:34:21.286"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:22.085" level="INFO">${result} = {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=64 time=171 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:22.085" starttime="20181224 22:34:22.084"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:22.086" level="INFO">{u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=64 time=171 ms\n80 bytes from 1.1.1.202: icmp_seq=3 ttl=64 time=183 ms\n80 bytes from 1.1.1.202: icmp_seq=4 ttl=64 time=194 ms\n80 bytes from 1.1.1.202: icmp_seq=5 ttl=64 time=206 ms\n\n--- 1.1.1.202 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 162.839/183.599/206.232/15.633 ms, pipe 5, ipg/ewma 11.077/174.380 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:22.086" starttime="20181224 22:34:22.085"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:22.087" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:22.087" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:22.087" starttime="20181224 22:34:22.086"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:22.088" starttime="20181224 22:34:22.087"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:22.088" starttime="20181224 22:34:21.285"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:22.088" starttime="20181224 22:34:21.285"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:22.088" starttime="20181224 22:34:21.284"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.203">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:22.089" level="INFO">1.1.1.203</msg>
<status status="PASS" endtime="20181224 22:34:22.089" starttime="20181224 22:34:22.088"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:22.945" level="INFO">${output} = [{'command': 'ping 1.1.1.203', 'result': {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=166 ms\n80 bytes from 1.1.1.203: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:22.946" starttime="20181224 22:34:22.090"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:22.947" level="INFO">${result} = {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=166 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=64 time=173 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:22.947" starttime="20181224 22:34:22.946"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:22.947" level="INFO">{u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=166 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=64 time=173 ms\n80 bytes from 1.1.1.203: icmp_seq=3 ttl=64 time=188 ms\n80 bytes from 1.1.1.203: icmp_seq=4 ttl=64 time=202 ms\n80 bytes from 1.1.1.203: icmp_seq=5 ttl=64 time=214 ms\n\n--- 1.1.1.203 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 45ms\nrtt min/avg/max/mdev = 166.679/189.174/214.067/17.570 ms, pipe 5, ipg/ewma 11.299/179.238 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:22.947" starttime="20181224 22:34:22.947"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:22.948" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:22.948" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:22.948" starttime="20181224 22:34:22.948"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:22.949" starttime="20181224 22:34:22.949"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:22.949" starttime="20181224 22:34:22.089"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:22.949" starttime="20181224 22:34:22.089"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:22.949" starttime="20181224 22:34:22.088"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.204">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:22.950" level="INFO">1.1.1.204</msg>
<status status="PASS" endtime="20181224 22:34:22.950" starttime="20181224 22:34:22.950"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:23.716" level="INFO">${output} = [{'command': 'ping 1.1.1.204', 'result': {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=186 ms\n80 bytes from 1.1.1.204: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:23.716" starttime="20181224 22:34:22.951"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:23.717" level="INFO">${result} = {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=186 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=64 time=196 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:23.717" starttime="20181224 22:34:23.716"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:23.718" level="INFO">{u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=186 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=64 time=196 ms\n80 bytes from 1.1.1.204: icmp_seq=3 ttl=64 time=208 ms\n80 bytes from 1.1.1.204: icmp_seq=4 ttl=64 time=220 ms\n80 bytes from 1.1.1.204: icmp_seq=5 ttl=64 time=231 ms\n\n--- 1.1.1.204 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 43ms\nrtt min/avg/max/mdev = 186.728/208.622/231.938/16.207 ms, pipe 5, ipg/ewma 10.974/198.874 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:23.718" starttime="20181224 22:34:23.717"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:23.719" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:23.719" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:23.719" starttime="20181224 22:34:23.718"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:23.720" starttime="20181224 22:34:23.719"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:23.720" starttime="20181224 22:34:22.951"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:23.720" starttime="20181224 22:34:22.950"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:23.720" starttime="20181224 22:34:22.949"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.1">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:23.720" level="INFO">2.2.2.1</msg>
<status status="PASS" endtime="20181224 22:34:23.720" starttime="20181224 22:34:23.720"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:24.536" level="INFO">${output} = [{'command': 'ping 2.2.2.1', 'result': {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=167 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 ti...</msg>
<status status="PASS" endtime="20181224 22:34:24.536" starttime="20181224 22:34:23.722"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:24.537" level="INFO">${result} = {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=167 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 time=174 ms\n80 bytes from 2.2.2.1: icmp_...</msg>
<status status="PASS" endtime="20181224 22:34:24.537" starttime="20181224 22:34:24.536"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:24.538" level="INFO">{u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=167 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 time=174 ms\n80 bytes from 2.2.2.1: icmp_seq=3 ttl=64 time=185 ms\n80 bytes from 2.2.2.1: icmp_seq=4 ttl=64 time=201 ms\n80 bytes from 2.2.2.1: icmp_seq=5 ttl=64 time=213 ms\n\n--- 2.2.2.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 45ms\nrtt min/avg/max/mdev = 167.998/188.806/213.491/16.819 ms, pipe 5, ipg/ewma 11.455/179.668 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:24.538" starttime="20181224 22:34:24.537"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:24.539" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:24.539" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:24.539" starttime="20181224 22:34:24.538"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:24.539" starttime="20181224 22:34:24.539"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:24.540" starttime="20181224 22:34:23.721"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:24.540" starttime="20181224 22:34:23.721"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:24.540" starttime="20181224 22:34:23.720"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.2">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:24.540" level="INFO">2.2.2.2</msg>
<status status="PASS" endtime="20181224 22:34:24.540" starttime="20181224 22:34:24.540"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:25.446" level="INFO">${output} = [{'command': 'ping 2.2.2.2', 'result': {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=297 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 ti...</msg>
<status status="PASS" endtime="20181224 22:34:25.446" starttime="20181224 22:34:24.542"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:25.447" level="INFO">${result} = {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=297 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 time=304 ms\n80 bytes from 2.2.2.2: icmp_...</msg>
<status status="PASS" endtime="20181224 22:34:25.447" starttime="20181224 22:34:25.446"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:25.448" level="INFO">{u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=297 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 time=304 ms\n80 bytes from 2.2.2.2: icmp_seq=3 ttl=64 time=314 ms\n80 bytes from 2.2.2.2: icmp_seq=4 ttl=64 time=324 ms\n80 bytes from 2.2.2.2: icmp_seq=5 ttl=64 time=334 ms\n\n--- 2.2.2.2 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 297.076/314.980/334.353/13.398 ms, pipe 5, ipg/ewma 11.221/307.021 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:25.448" starttime="20181224 22:34:25.447"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:25.449" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:25.449" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:25.449" starttime="20181224 22:34:25.448"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:25.450" starttime="20181224 22:34:25.449"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:25.450" starttime="20181224 22:34:24.541"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:25.450" starttime="20181224 22:34:24.541"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:25.450" starttime="20181224 22:34:24.540"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:25.450" starttime="20181224 22:34:18.908"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:25.450" starttime="20181224 22:34:18.908"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:25.450" starttime="20181224 22:34:15.714"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:25.450" starttime="20181224 22:34:15.710"></status>
</kw>
<kw type="foritem" name="${spine} = DCA-Spine2">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:25.451" starttime="20181224 22:34:25.451"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:34:25.451" level="INFO">${switch_info} = {'username': 'admin', 'index': 2, 'node': Node(connection=EapiConnection(transport=https://10.255.255.102:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine2', 'host': '10.255.255.102', 'tra...</msg>
<status status="PASS" endtime="20181224 22:34:25.452" starttime="20181224 22:34:25.451"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:34:25.452" level="INFO">{'username': 'admin', 'index': 2, 'node': Node(connection=EapiConnection(transport=https://10.255.255.102:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine2', 'host': '10.255.255.102', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.102:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:34:25.452" starttime="20181224 22:34:25.452"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<msg timestamp="20181224 22:34:25.452" level="INFO">DCA-Spine2</msg>
<status status="PASS" endtime="20181224 22:34:25.453" starttime="20181224 22:34:25.452"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${spines}</arg>
<arg>${spine}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:25.453" level="INFO">${target_dictionary} = {'p2p_ping': ['10.102.201.1', '10.102.202.1', '10.102.203.1', '10.102.204.1'], 'management_ip': '10.255.255.102', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ...</msg>
<status status="PASS" endtime="20181224 22:34:25.453" starttime="20181224 22:34:25.453"></status>
</kw>
<kw name="Initiate All Spine Ping Tests" library="Ping_All">
<doc>Running all Ping Tests on Spines</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<kw name="Ping Spine P2Ps" library="Ping_P2Ps">
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>p2p_ping</arg>
</arguments>
<assign>
<var>@{p2ps}</var>
</assign>
<msg timestamp="20181224 22:34:25.454" level="INFO">@{p2ps} = [ 10.102.201.1 | 10.102.202.1 | 10.102.203.1 | 10.102.204.1 ]</msg>
<status status="PASS" endtime="20181224 22:34:25.455" starttime="20181224 22:34:25.454"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<msg timestamp="20181224 22:34:25.455" level="INFO">{'p2p_ping': ['10.102.201.1', '10.102.202.1', '10.102.203.1', '10.102.204.1'], 'management_ip': '10.255.255.102', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'loopback': '1.1.1.102'}</msg>
<status status="PASS" endtime="20181224 22:34:25.455" starttime="20181224 22:34:25.455"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${p2ps}</arg>
</arguments>
<msg timestamp="20181224 22:34:25.455" level="INFO">['10.102.201.1', '10.102.202.1', '10.102.203.1', '10.102.204.1']</msg>
<status status="PASS" endtime="20181224 22:34:25.455" starttime="20181224 22:34:25.455"></status>
</kw>
<kw type="for" name="${ip} IN [ @{p2ps} ]">
<kw type="foritem" name="${ip} = 10.102.201.1">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${ip}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${ip}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:26.482" level="INFO">${output} = [{'command': 'ping 10.102.201.1', 'result': {u'messages': [u'PING 10.102.201.1 (10.102.201.1) 72(100) bytes of data.\n80 bytes from 10.102.201.1: icmp_seq=1 ttl=64 time=277 ms\n80 bytes from 10.102.20...</msg>
<status status="PASS" endtime="20181224 22:34:26.482" starttime="20181224 22:34:25.457"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:26.483" level="INFO">${result} = {u'messages': [u'PING 10.102.201.1 (10.102.201.1) 72(100) bytes of data.\n80 bytes from 10.102.201.1: icmp_seq=1 ttl=64 time=277 ms\n80 bytes from 10.102.201.1: icmp_seq=2 ttl=64 time=287 ms\n80 bytes...</msg>
<status status="PASS" endtime="20181224 22:34:26.483" starttime="20181224 22:34:26.483"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:26.484" level="INFO">{u'messages': [u'PING 10.102.201.1 (10.102.201.1) 72(100) bytes of data.\n80 bytes from 10.102.201.1: icmp_seq=1 ttl=64 time=277 ms\n80 bytes from 10.102.201.1: icmp_seq=2 ttl=64 time=287 ms\n80 bytes from 10.102.201.1: icmp_seq=3 ttl=64 time=300 ms\n80 bytes from 10.102.201.1: icmp_seq=4 ttl=64 time=312 ms\n80 bytes from 10.102.201.1: icmp_seq=5 ttl=64 time=325 ms\n\n--- 10.102.201.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 277.868/300.724/325.704/17.181 ms, pipe 5, ipg/ewma 11.195/290.571 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:26.484" starttime="20181224 22:34:26.484"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:26.485" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:26.485" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:26.485" starttime="20181224 22:34:26.484"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:26.486" starttime="20181224 22:34:26.485"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:26.486" starttime="20181224 22:34:25.456"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:26.486" starttime="20181224 22:34:25.456"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:26.486" starttime="20181224 22:34:25.456"></status>
</kw>
<kw type="foritem" name="${ip} = 10.102.202.1">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${ip}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${ip}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:27.485" level="INFO">${output} = [{'command': 'ping 10.102.202.1', 'result': {u'messages': [u'PING 10.102.202.1 (10.102.202.1) 72(100) bytes of data.\n80 bytes from 10.102.202.1: icmp_seq=1 ttl=64 time=176 ms\n80 bytes from 10.102.20...</msg>
<status status="PASS" endtime="20181224 22:34:27.485" starttime="20181224 22:34:26.487"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:27.486" level="INFO">${result} = {u'messages': [u'PING 10.102.202.1 (10.102.202.1) 72(100) bytes of data.\n80 bytes from 10.102.202.1: icmp_seq=1 ttl=64 time=176 ms\n80 bytes from 10.102.202.1: icmp_seq=2 ttl=64 time=186 ms\n80 bytes...</msg>
<status status="PASS" endtime="20181224 22:34:27.486" starttime="20181224 22:34:27.485"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:27.487" level="INFO">{u'messages': [u'PING 10.102.202.1 (10.102.202.1) 72(100) bytes of data.\n80 bytes from 10.102.202.1: icmp_seq=1 ttl=64 time=176 ms\n80 bytes from 10.102.202.1: icmp_seq=2 ttl=64 time=186 ms\n80 bytes from 10.102.202.1: icmp_seq=3 ttl=64 time=197 ms\n80 bytes from 10.102.202.1: icmp_seq=4 ttl=64 time=210 ms\n80 bytes from 10.102.202.1: icmp_seq=5 ttl=64 time=222 ms\n\n--- 10.102.202.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 176.950/198.687/222.359/16.262 ms, pipe 5, ipg/ewma 11.004/189.025 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:27.487" starttime="20181224 22:34:27.486"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:27.488" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:27.488" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:27.488" starttime="20181224 22:34:27.487"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:27.488" starttime="20181224 22:34:27.488"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:27.489" starttime="20181224 22:34:26.487"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:27.489" starttime="20181224 22:34:26.486"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:27.489" starttime="20181224 22:34:26.486"></status>
</kw>
<kw type="foritem" name="${ip} = 10.102.203.1">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${ip}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${ip}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:28.296" level="INFO">${output} = [{'command': 'ping 10.102.203.1', 'result': {u'messages': [u'PING 10.102.203.1 (10.102.203.1) 72(100) bytes of data.\n80 bytes from 10.102.203.1: icmp_seq=1 ttl=64 time=212 ms\n80 bytes from 10.102.20...</msg>
<status status="PASS" endtime="20181224 22:34:28.296" starttime="20181224 22:34:27.490"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:28.297" level="INFO">${result} = {u'messages': [u'PING 10.102.203.1 (10.102.203.1) 72(100) bytes of data.\n80 bytes from 10.102.203.1: icmp_seq=1 ttl=64 time=212 ms\n80 bytes from 10.102.203.1: icmp_seq=2 ttl=64 time=222 ms\n80 bytes...</msg>
<status status="PASS" endtime="20181224 22:34:28.297" starttime="20181224 22:34:28.296"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:28.297" level="INFO">{u'messages': [u'PING 10.102.203.1 (10.102.203.1) 72(100) bytes of data.\n80 bytes from 10.102.203.1: icmp_seq=1 ttl=64 time=212 ms\n80 bytes from 10.102.203.1: icmp_seq=2 ttl=64 time=222 ms\n80 bytes from 10.102.203.1: icmp_seq=3 ttl=64 time=234 ms\n80 bytes from 10.102.203.1: icmp_seq=4 ttl=64 time=247 ms\n80 bytes from 10.102.203.1: icmp_seq=5 ttl=64 time=260 ms\n\n--- 10.102.203.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 43ms\nrtt min/avg/max/mdev = 212.547/235.337/260.195/17.041 ms, pipe 5, ipg/ewma 10.995/225.206 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:28.298" starttime="20181224 22:34:28.297"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:28.298" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:28.299" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:28.299" starttime="20181224 22:34:28.298"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:28.299" starttime="20181224 22:34:28.299"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:28.300" starttime="20181224 22:34:27.489"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:28.300" starttime="20181224 22:34:27.489"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:28.300" starttime="20181224 22:34:27.489"></status>
</kw>
<kw type="foritem" name="${ip} = 10.102.204.1">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${ip}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${ip}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:29.117" level="INFO">${output} = [{'command': 'ping 10.102.204.1', 'result': {u'messages': [u'PING 10.102.204.1 (10.102.204.1) 72(100) bytes of data.\n80 bytes from 10.102.204.1: icmp_seq=1 ttl=64 time=176 ms\n80 bytes from 10.102.20...</msg>
<status status="PASS" endtime="20181224 22:34:29.117" starttime="20181224 22:34:28.301"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:29.118" level="INFO">${result} = {u'messages': [u'PING 10.102.204.1 (10.102.204.1) 72(100) bytes of data.\n80 bytes from 10.102.204.1: icmp_seq=1 ttl=64 time=176 ms\n80 bytes from 10.102.204.1: icmp_seq=2 ttl=64 time=185 ms\n80 bytes...</msg>
<status status="PASS" endtime="20181224 22:34:29.118" starttime="20181224 22:34:29.117"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:29.118" level="INFO">{u'messages': [u'PING 10.102.204.1 (10.102.204.1) 72(100) bytes of data.\n80 bytes from 10.102.204.1: icmp_seq=1 ttl=64 time=176 ms\n80 bytes from 10.102.204.1: icmp_seq=2 ttl=64 time=185 ms\n80 bytes from 10.102.204.1: icmp_seq=3 ttl=64 time=210 ms\n80 bytes from 10.102.204.1: icmp_seq=4 ttl=64 time=246 ms\n80 bytes from 10.102.204.1: icmp_seq=5 ttl=64 time=259 ms\n\n--- 10.102.204.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 176.663/215.450/259.015/32.509 ms, pipe 5, ipg/ewma 11.140/198.483 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:29.119" starttime="20181224 22:34:29.118"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:29.119" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:29.119" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:29.119" starttime="20181224 22:34:29.119"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:29.120" starttime="20181224 22:34:29.120"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:29.120" starttime="20181224 22:34:28.300"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:29.120" starttime="20181224 22:34:28.300"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:29.120" starttime="20181224 22:34:28.300"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:29.120" starttime="20181224 22:34:25.456"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:29.121" starttime="20181224 22:34:25.454"></status>
</kw>
<kw name="Ping Spine Loopbacks" library="Ping_Loopbacks">
<kw type="for" name="${loopback} IN [ @{loopback_ping} ]">
<kw type="foritem" name="${loopback} = 1.1.1.101">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:29.122" level="INFO">1.1.1.101</msg>
<status status="PASS" endtime="20181224 22:34:29.122" starttime="20181224 22:34:29.121"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:30.180" level="INFO">${output} = [{'command': 'ping 1.1.1.101', 'result': {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=63 time=425 ms\n80 bytes from 1.1.1.101: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:30.181" starttime="20181224 22:34:29.123"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:30.182" level="INFO">${result} = {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=63 time=425 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=63 time=434 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:30.182" starttime="20181224 22:34:30.181"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:30.182" level="INFO">{u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=63 time=425 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=63 time=434 ms\n80 bytes from 1.1.1.101: icmp_seq=3 ttl=63 time=445 ms\n80 bytes from 1.1.1.101: icmp_seq=4 ttl=63 time=458 ms\n80 bytes from 1.1.1.101: icmp_seq=5 ttl=63 time=470 ms\n\n--- 1.1.1.101 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 425.250/446.910/470.518/16.326 ms, pipe 5, ipg/ewma 11.091/437.293 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:30.182" starttime="20181224 22:34:30.182"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:30.183" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:30.183" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:30.183" starttime="20181224 22:34:30.183"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:30.184" starttime="20181224 22:34:30.184"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:30.184" starttime="20181224 22:34:29.122"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:30.184" starttime="20181224 22:34:29.122"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:30.184" starttime="20181224 22:34:29.121"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.102">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:30.185" level="INFO">1.1.1.102</msg>
<status status="PASS" endtime="20181224 22:34:30.185" starttime="20181224 22:34:30.185"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:30.809" level="INFO">${output} = [{'command': 'ping 1.1.1.102', 'result': {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=0.067 ms\n80 bytes from 1.1.1.102: icmp_seq...</msg>
<status status="PASS" endtime="20181224 22:34:30.809" starttime="20181224 22:34:30.186"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:30.810" level="INFO">${result} = {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=0.067 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=64 time=0.027 ms\n80 bytes from 1....</msg>
<status status="PASS" endtime="20181224 22:34:30.810" starttime="20181224 22:34:30.809"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:30.810" level="INFO">{u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=0.067 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=64 time=0.027 ms\n80 bytes from 1.1.1.102: icmp_seq=3 ttl=64 time=0.023 ms\n80 bytes from 1.1.1.102: icmp_seq=4 ttl=64 time=0.022 ms\n80 bytes from 1.1.1.102: icmp_seq=5 ttl=64 time=0.022 ms\n\n--- 1.1.1.102 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.022/0.032/0.067/0.017 ms, ipg/ewma 0.068/0.049 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:30.811" starttime="20181224 22:34:30.810"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:30.811" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:30.811" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:30.811" starttime="20181224 22:34:30.811"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:30.812" starttime="20181224 22:34:30.812"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:30.813" starttime="20181224 22:34:30.186"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:30.813" starttime="20181224 22:34:30.185"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:30.813" starttime="20181224 22:34:30.184"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.201">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:30.813" level="INFO">1.1.1.201</msg>
<status status="PASS" endtime="20181224 22:34:30.813" starttime="20181224 22:34:30.813"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:31.559" level="INFO">${output} = [{'command': 'ping 1.1.1.201', 'result': {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 1.1.1.201: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:31.559" starttime="20181224 22:34:30.814"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:31.560" level="INFO">${result} = {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=64 time=170 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:31.560" starttime="20181224 22:34:31.560"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:31.561" level="INFO">{u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=64 time=170 ms\n80 bytes from 1.1.1.201: icmp_seq=3 ttl=64 time=182 ms\n80 bytes from 1.1.1.201: icmp_seq=4 ttl=64 time=194 ms\n80 bytes from 1.1.1.201: icmp_seq=5 ttl=64 time=209 ms\n\n--- 1.1.1.201 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 162.924/183.996/209.626/16.625 ms, pipe 5, ipg/ewma 11.647/174.708 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:31.561" starttime="20181224 22:34:31.561"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:31.562" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:31.562" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:31.562" starttime="20181224 22:34:31.561"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:31.563" starttime="20181224 22:34:31.562"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:31.563" starttime="20181224 22:34:30.814"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:31.563" starttime="20181224 22:34:30.814"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:31.563" starttime="20181224 22:34:30.813"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.202">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:31.564" level="INFO">1.1.1.202</msg>
<status status="PASS" endtime="20181224 22:34:31.564" starttime="20181224 22:34:31.563"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:32.335" level="INFO">${output} = [{'command': 'ping 1.1.1.202', 'result': {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 1.1.1.202: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:32.335" starttime="20181224 22:34:31.565"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:32.336" level="INFO">${result} = {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=64 time=172 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:32.336" starttime="20181224 22:34:32.335"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:32.337" level="INFO">{u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=64 time=172 ms\n80 bytes from 1.1.1.202: icmp_seq=3 ttl=64 time=185 ms\n80 bytes from 1.1.1.202: icmp_seq=4 ttl=64 time=198 ms\n80 bytes from 1.1.1.202: icmp_seq=5 ttl=64 time=209 ms\n\n--- 1.1.1.202 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 45ms\nrtt min/avg/max/mdev = 162.591/185.733/209.856/16.976 ms, pipe 5, ipg/ewma 11.340/175.414 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:32.337" starttime="20181224 22:34:32.336"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:32.337" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:32.338" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:32.338" starttime="20181224 22:34:32.337"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:32.338" starttime="20181224 22:34:32.338"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:32.338" starttime="20181224 22:34:31.564"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:32.339" starttime="20181224 22:34:31.564"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:32.339" starttime="20181224 22:34:31.563"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.203">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:32.339" level="INFO">1.1.1.203</msg>
<status status="PASS" endtime="20181224 22:34:32.339" starttime="20181224 22:34:32.339"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:33.180" level="INFO">${output} = [{'command': 'ping 1.1.1.203', 'result': {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=220 ms\n80 bytes from 1.1.1.203: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:33.180" starttime="20181224 22:34:32.340"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:33.181" level="INFO">${result} = {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=220 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=64 time=229 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:33.181" starttime="20181224 22:34:33.181"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:33.182" level="INFO">{u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=220 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=64 time=229 ms\n80 bytes from 1.1.1.203: icmp_seq=3 ttl=64 time=241 ms\n80 bytes from 1.1.1.203: icmp_seq=4 ttl=64 time=253 ms\n80 bytes from 1.1.1.203: icmp_seq=5 ttl=64 time=266 ms\n\n--- 1.1.1.203 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 43ms\nrtt min/avg/max/mdev = 220.438/242.206/266.577/16.532 ms, pipe 5, ipg/ewma 10.990/232.553 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:33.182" starttime="20181224 22:34:33.182"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:33.183" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:33.183" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:33.183" starttime="20181224 22:34:33.182"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:33.184" starttime="20181224 22:34:33.183"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:33.184" starttime="20181224 22:34:32.340"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:33.184" starttime="20181224 22:34:32.339"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:33.184" starttime="20181224 22:34:32.339"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.204">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:33.185" level="INFO">1.1.1.204</msg>
<status status="PASS" endtime="20181224 22:34:33.185" starttime="20181224 22:34:33.184"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:33.969" level="INFO">${output} = [{'command': 'ping 1.1.1.204', 'result': {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=161 ms\n80 bytes from 1.1.1.204: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:33.969" starttime="20181224 22:34:33.186"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:33.970" level="INFO">${result} = {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=161 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=64 time=170 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:33.970" starttime="20181224 22:34:33.969"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:33.971" level="INFO">{u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=161 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=64 time=170 ms\n80 bytes from 1.1.1.204: icmp_seq=3 ttl=64 time=198 ms\n80 bytes from 1.1.1.204: icmp_seq=4 ttl=64 time=212 ms\n80 bytes from 1.1.1.204: icmp_seq=5 ttl=64 time=225 ms\n\n--- 1.1.1.204 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 43ms\nrtt min/avg/max/mdev = 161.055/193.559/225.231/24.352 ms, pipe 5, ipg/ewma 10.983/179.074 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:33.971" starttime="20181224 22:34:33.970"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:33.971" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:33.972" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:33.972" starttime="20181224 22:34:33.971"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:33.972" starttime="20181224 22:34:33.972"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:33.972" starttime="20181224 22:34:33.185"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:33.973" starttime="20181224 22:34:33.185"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:33.973" starttime="20181224 22:34:33.184"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.1">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:33.973" level="INFO">2.2.2.1</msg>
<status status="PASS" endtime="20181224 22:34:33.973" starttime="20181224 22:34:33.973"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:34.782" level="INFO">${output} = [{'command': 'ping 2.2.2.1', 'result': {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 ti...</msg>
<status status="PASS" endtime="20181224 22:34:34.782" starttime="20181224 22:34:33.974"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:34.783" level="INFO">${result} = {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 time=169 ms\n80 bytes from 2.2.2.1: icmp_...</msg>
<status status="PASS" endtime="20181224 22:34:34.783" starttime="20181224 22:34:34.783"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:34.784" level="INFO">{u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=162 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 time=169 ms\n80 bytes from 2.2.2.1: icmp_seq=3 ttl=64 time=181 ms\n80 bytes from 2.2.2.1: icmp_seq=4 ttl=64 time=210 ms\n80 bytes from 2.2.2.1: icmp_seq=5 ttl=64 time=223 ms\n\n--- 2.2.2.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 45ms\nrtt min/avg/max/mdev = 162.321/189.582/223.108/23.534 ms, pipe 5, ipg/ewma 11.288/177.720 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:34.784" starttime="20181224 22:34:34.784"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:34.785" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:34.785" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:34.785" starttime="20181224 22:34:34.785"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:34.786" starttime="20181224 22:34:34.785"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:34.786" starttime="20181224 22:34:33.974"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:34.786" starttime="20181224 22:34:33.973"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:34.786" starttime="20181224 22:34:33.973"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.2">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:34.787" level="INFO">2.2.2.2</msg>
<status status="PASS" endtime="20181224 22:34:34.787" starttime="20181224 22:34:34.786"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:35.688" level="INFO">${output} = [{'command': 'ping 2.2.2.2', 'result': {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=168 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 ti...</msg>
<status status="PASS" endtime="20181224 22:34:35.688" starttime="20181224 22:34:34.788"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:35.689" level="INFO">${result} = {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=168 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 time=174 ms\n80 bytes from 2.2.2.2: icmp_...</msg>
<status status="PASS" endtime="20181224 22:34:35.689" starttime="20181224 22:34:35.689"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:35.690" level="INFO">{u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=168 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 time=174 ms\n80 bytes from 2.2.2.2: icmp_seq=3 ttl=64 time=187 ms\n80 bytes from 2.2.2.2: icmp_seq=4 ttl=64 time=203 ms\n80 bytes from 2.2.2.2: icmp_seq=5 ttl=64 time=216 ms\n\n--- 2.2.2.2 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 168.065/190.092/216.313/17.908 ms, pipe 5, ipg/ewma 11.581/180.427 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:35.690" starttime="20181224 22:34:35.690"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:35.691" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:35.691" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:35.691" starttime="20181224 22:34:35.690"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:35.692" starttime="20181224 22:34:35.691"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:35.692" starttime="20181224 22:34:34.787"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:35.692" starttime="20181224 22:34:34.787"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:35.692" starttime="20181224 22:34:34.786"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:35.692" starttime="20181224 22:34:29.121"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:35.692" starttime="20181224 22:34:29.121"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:35.692" starttime="20181224 22:34:25.453"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:35.692" starttime="20181224 22:34:25.450"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:35.692" starttime="20181224 22:34:15.710"></status>
</kw>
<doc>Validate Spines are able to ping p2p and loopbacks</doc>
<tags>
<tag>SPINE_PING</tag>
</tags>
<status status="PASS" endtime="20181224 22:34:35.692" critical="yes" starttime="20181224 22:34:15.709"></status>
</test>
<test id="s1-t2" name="Spine OSPF Neighbor Validation">
<kw type="for" name="${spine} IN [ @{spines} ]">
<kw type="foritem" name="${spine} = DCA-Spine1">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:35.694" starttime="20181224 22:34:35.694"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:34:35.695" level="INFO">${switch_info} = {'username': 'admin', 'index': 1, 'node': Node(connection=EapiConnection(transport=https://10.255.255.101:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine1', 'host': '10.255.255.101', 'tra...</msg>
<status status="PASS" endtime="20181224 22:34:35.695" starttime="20181224 22:34:35.695"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:34:35.695" level="INFO">{'username': 'admin', 'index': 1, 'node': Node(connection=EapiConnection(transport=https://10.255.255.101:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine1', 'host': '10.255.255.101', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.101:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:34:35.696" starttime="20181224 22:34:35.695"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<msg timestamp="20181224 22:34:35.696" level="INFO">DCA-Spine1</msg>
<status status="PASS" endtime="20181224 22:34:35.696" starttime="20181224 22:34:35.696"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${spines}</arg>
<arg>${spine}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:35.697" level="INFO">${target_dictionary} = {'p2p_ping': ['10.101.201.1', '10.101.202.1', '10.101.203.1', '10.101.204.1'], 'management_ip': '10.255.255.101', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ...</msg>
<status status="PASS" endtime="20181224 22:34:35.697" starttime="20181224 22:34:35.696"></status>
</kw>
<kw name="Validate OSPF Neighbors" library="Validate_OSPF_Neighbors">
<doc>Validating OSPF Neighbors on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${spine}</arg>
</arguments>
<kw name="Get Neighbors" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_neighbors}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show ip ospf neighbor</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:34:35.698" level="INFO">${cmd} = show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:34:35.698" starttime="20181224 22:34:35.698"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:34:35.699" level="INFO">show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:34:35.699" starttime="20181224 22:34:35.698"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.326" starttime="20181224 22:34:35.700"></status>
</kw>
<msg timestamp="20181224 22:34:36.326" level="INFO">${result} = [{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712169.047574, u'priority': 0, u'interfaceName': u'Ethernet2',...</msg>
<status status="PASS" endtime="20181224 22:34:36.326" starttime="20181224 22:34:35.699"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.327" level="INFO">{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712169.047574, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 3, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629736.047819}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.202.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712172.049339, u'priority': 0, u'interfaceName': u'Ethernet3', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 11, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629724.049544}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.203.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712170.050945, u'priority': 0, u'interfaceName': u'Ethernet4', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 33, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629738.05116}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.204.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712177.052538, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545711835.0528}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.201.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]}}}}}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:34:36.328" starttime="20181224 22:34:36.327"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']['vrfs']['default']['instList']['1']}</arg>
<arg>ospfNeighborEntries</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:34:36.328" level="INFO">${result_dict} = [{u'inactivity': 1545712169.047574, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:34:36.328" starttime="20181224 22:34:36.328"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.329" level="INFO">[{u'inactivity': 1545712169.047574, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 3, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629736.047819}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.202.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712172.049339, u'priority': 0, u'interfaceName': u'Ethernet3', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 11, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629724.049544}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.203.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712170.050945, u'priority': 0, u'interfaceName': u'Ethernet4', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 33, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629738.05116}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.204.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712177.052538, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545711835.0528}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.201.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:34:36.329" starttime="20181224 22:34:36.329"></status>
</kw>
<msg timestamp="20181224 22:34:36.330" level="INFO">${current_neighbors} = [{u'inactivity': 1545712169.047574, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:34:36.330" starttime="20181224 22:34:35.698"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.330" level="INFO">[{u'inactivity': 1545712169.047574, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 3, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629736.047819}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.202.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712172.049339, u'priority': 0, u'interfaceName': u'Ethernet3', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 11, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629724.049544}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.203.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712170.050945, u'priority': 0, u'interfaceName': u'Ethernet4', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 33, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629738.05116}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.204.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712177.052538, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545711835.0528}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.201.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:34:36.331" starttime="20181224 22:34:36.330"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>ospf_neighbors</arg>
</arguments>
<assign>
<var>@{target_neighbors}</var>
</assign>
<msg timestamp="20181224 22:34:36.331" level="INFO">@{target_neighbors} = [ 1.1.1.201 | 1.1.1.202 | 1.1.1.203 | 1.1.1.204 ]</msg>
<status status="PASS" endtime="20181224 22:34:36.331" starttime="20181224 22:34:36.331"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate OSPF Validation</arg>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Initiate OSPF Validation" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_neighbors}</var>
</assign>
<msg timestamp="20181224 22:34:36.333" level="INFO">@{established_neighbors} = [ ]</msg>
<status status="PASS" endtime="20181224 22:34:36.333" starttime="20181224 22:34:36.332"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.333" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:34:36.333" starttime="20181224 22:34:36.333"></status>
</kw>
<kw type="for" name="${cNeighbor} IN [ @{current_neighbors} ]">
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712169.047574, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.334" level="INFO">{u'inactivity': 1545712169.047574, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 3, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629736.047819}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.202.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:34:36.334" starttime="20181224 22:34:36.334"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:34:36.336" level="INFO">1.1.1.202 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:34:36.336" starttime="20181224 22:34:36.336"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.336" starttime="20181224 22:34:36.335"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.336" starttime="20181224 22:34:36.335"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.337" starttime="20181224 22:34:36.334"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.338" starttime="20181224 22:34:36.338"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.338" starttime="20181224 22:34:36.337"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.338" starttime="20181224 22:34:36.337"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:34:36.339" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:34:36.339" level="INFO">${established_neighbors_length} = 1</msg>
<status status="PASS" endtime="20181224 22:34:36.339" starttime="20181224 22:34:36.339"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.340" level="INFO">[u'1.1.1.202']</msg>
<status status="PASS" endtime="20181224 22:34:36.340" starttime="20181224 22:34:36.340"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.340" starttime="20181224 22:34:36.339"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.341" starttime="20181224 22:34:36.340"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.341" starttime="20181224 22:34:36.340"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.341" starttime="20181224 22:34:36.333"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712172.049339, u'priority': 0, u'interfaceName': u'Ethernet3', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.342" level="INFO">{u'inactivity': 1545712172.049339, u'priority': 0, u'interfaceName': u'Ethernet3', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 11, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629724.049544}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.203.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:34:36.342" starttime="20181224 22:34:36.341"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:34:36.344" level="INFO">1.1.1.203 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:34:36.344" starttime="20181224 22:34:36.343"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.344" starttime="20181224 22:34:36.343"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.344" starttime="20181224 22:34:36.342"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.344" starttime="20181224 22:34:36.342"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.345" starttime="20181224 22:34:36.345"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.346" starttime="20181224 22:34:36.344"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.346" starttime="20181224 22:34:36.344"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:34:36.346" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:34:36.346" level="INFO">${established_neighbors_length} = 2</msg>
<status status="PASS" endtime="20181224 22:34:36.346" starttime="20181224 22:34:36.346"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.347" level="INFO">[u'1.1.1.202', u'1.1.1.203']</msg>
<status status="PASS" endtime="20181224 22:34:36.347" starttime="20181224 22:34:36.347"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.347" starttime="20181224 22:34:36.346"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.348" starttime="20181224 22:34:36.348"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.348" starttime="20181224 22:34:36.347"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.348" starttime="20181224 22:34:36.341"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712170.050945, u'priority': 0, u'interfaceName': u'Ethernet4', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.349" level="INFO">{u'inactivity': 1545712170.050945, u'priority': 0, u'interfaceName': u'Ethernet4', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 33, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629738.05116}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.204.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:34:36.349" starttime="20181224 22:34:36.348"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:34:36.350" level="INFO">1.1.1.204 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:34:36.350" starttime="20181224 22:34:36.350"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.350" starttime="20181224 22:34:36.350"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.351" starttime="20181224 22:34:36.349"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.351" starttime="20181224 22:34:36.349"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.352" starttime="20181224 22:34:36.352"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.352" starttime="20181224 22:34:36.351"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.352" starttime="20181224 22:34:36.351"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:34:36.352" level="INFO">Length is 3</msg>
<msg timestamp="20181224 22:34:36.352" level="INFO">${established_neighbors_length} = 3</msg>
<status status="PASS" endtime="20181224 22:34:36.352" starttime="20181224 22:34:36.352"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.353" level="INFO">[u'1.1.1.202', u'1.1.1.203', u'1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:34:36.353" starttime="20181224 22:34:36.353"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.353" starttime="20181224 22:34:36.353"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.354" starttime="20181224 22:34:36.354"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.354" starttime="20181224 22:34:36.353"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.354" starttime="20181224 22:34:36.348"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712177.052538, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.355" level="INFO">{u'inactivity': 1545712177.052538, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545711835.0528}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.201.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:34:36.355" starttime="20181224 22:34:36.354"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:34:36.356" level="INFO">1.1.1.201 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:34:36.356" starttime="20181224 22:34:36.356"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.357" starttime="20181224 22:34:36.356"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.357" starttime="20181224 22:34:36.355"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.357" starttime="20181224 22:34:36.355"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.358" starttime="20181224 22:34:36.358"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.358" starttime="20181224 22:34:36.357"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.358" starttime="20181224 22:34:36.357"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:34:36.358" level="INFO">Length is 4</msg>
<msg timestamp="20181224 22:34:36.359" level="INFO">${established_neighbors_length} = 4</msg>
<status status="PASS" endtime="20181224 22:34:36.359" starttime="20181224 22:34:36.358"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.359" level="INFO">[u'1.1.1.202', u'1.1.1.203', u'1.1.1.204', u'1.1.1.201']</msg>
<status status="PASS" endtime="20181224 22:34:36.359" starttime="20181224 22:34:36.359"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.359" starttime="20181224 22:34:36.359"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.360" starttime="20181224 22:34:36.360"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.360" starttime="20181224 22:34:36.360"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.360" starttime="20181224 22:34:36.354"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.361" starttime="20181224 22:34:36.333"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.361" level="INFO">[u'1.1.1.202', u'1.1.1.203', u'1.1.1.204', u'1.1.1.201']</msg>
<status status="PASS" endtime="20181224 22:34:36.361" starttime="20181224 22:34:36.361"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.361" level="INFO">['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:34:36.361" starttime="20181224 22:34:36.361"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_neighbors} ]">
<kw type="foritem" name="${listObject} = 1.1.1.201">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.362" starttime="20181224 22:34:36.362"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.362" starttime="20181224 22:34:36.362"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.362" starttime="20181224 22:34:36.362"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.202">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.363" starttime="20181224 22:34:36.363"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.363" starttime="20181224 22:34:36.363"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.363" starttime="20181224 22:34:36.362"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.203">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.364" starttime="20181224 22:34:36.364"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.364" starttime="20181224 22:34:36.364"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.364" starttime="20181224 22:34:36.363"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.204">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.365" starttime="20181224 22:34:36.365"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.365" starttime="20181224 22:34:36.364"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.365" starttime="20181224 22:34:36.364"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.365" starttime="20181224 22:34:36.361"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.365" starttime="20181224 22:34:36.332"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.365" starttime="20181224 22:34:36.331"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.365" starttime="20181224 22:34:35.697"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.366" starttime="20181224 22:34:35.694"></status>
</kw>
<kw type="foritem" name="${spine} = DCA-Spine2">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.366" starttime="20181224 22:34:36.366"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:34:36.366" level="INFO">${switch_info} = {'username': 'admin', 'index': 2, 'node': Node(connection=EapiConnection(transport=https://10.255.255.102:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine2', 'host': '10.255.255.102', 'tra...</msg>
<status status="PASS" endtime="20181224 22:34:36.366" starttime="20181224 22:34:36.366"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.367" level="INFO">{'username': 'admin', 'index': 2, 'node': Node(connection=EapiConnection(transport=https://10.255.255.102:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine2', 'host': '10.255.255.102', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.102:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:34:36.367" starttime="20181224 22:34:36.366"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.367" level="INFO">DCA-Spine2</msg>
<status status="PASS" endtime="20181224 22:34:36.367" starttime="20181224 22:34:36.367"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${spines}</arg>
<arg>${spine}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:36.368" level="INFO">${target_dictionary} = {'p2p_ping': ['10.102.201.1', '10.102.202.1', '10.102.203.1', '10.102.204.1'], 'management_ip': '10.255.255.102', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ...</msg>
<status status="PASS" endtime="20181224 22:34:36.368" starttime="20181224 22:34:36.367"></status>
</kw>
<kw name="Validate OSPF Neighbors" library="Validate_OSPF_Neighbors">
<doc>Validating OSPF Neighbors on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${spine}</arg>
</arguments>
<kw name="Get Neighbors" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_neighbors}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show ip ospf neighbor</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:34:36.369" level="INFO">${cmd} = show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:34:36.369" starttime="20181224 22:34:36.368"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.369" level="INFO">show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:34:36.369" starttime="20181224 22:34:36.369"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.782" starttime="20181224 22:34:36.369"></status>
</kw>
<msg timestamp="20181224 22:34:36.782" level="INFO">${result} = [{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712177.177766, u'priority': 0, u'interfaceName': u'Ethernet1',...</msg>
<status status="PASS" endtime="20181224 22:34:36.783" starttime="20181224 22:34:36.369"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.783" level="INFO">{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712177.177766, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 2, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.178041}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.201.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712178.179529, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 15, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.179747}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.202.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712177.181715, u'priority': 0, u'interfaceName': u'Ethernet3', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 9, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629733.181934}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.203.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712170.183892, u'priority': 0, u'interfaceName': u'Ethernet4', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 35, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629731.184119}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.204.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]}}}}}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:34:36.784" starttime="20181224 22:34:36.783"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']['vrfs']['default']['instList']['1']}</arg>
<arg>ospfNeighborEntries</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:34:36.785" level="INFO">${result_dict} = [{u'inactivity': 1545712177.177766, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:34:36.785" starttime="20181224 22:34:36.784"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.785" level="INFO">[{u'inactivity': 1545712177.177766, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 2, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.178041}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.201.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712178.179529, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 15, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.179747}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.202.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712177.181715, u'priority': 0, u'interfaceName': u'Ethernet3', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 9, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629733.181934}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.203.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712170.183892, u'priority': 0, u'interfaceName': u'Ethernet4', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 35, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629731.184119}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.204.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:34:36.785" starttime="20181224 22:34:36.785"></status>
</kw>
<msg timestamp="20181224 22:34:36.786" level="INFO">${current_neighbors} = [{u'inactivity': 1545712177.177766, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:34:36.786" starttime="20181224 22:34:36.368"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.786" level="INFO">[{u'inactivity': 1545712177.177766, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 2, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.178041}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.201.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712178.179529, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 15, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.179747}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.202.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712177.181715, u'priority': 0, u'interfaceName': u'Ethernet3', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 9, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629733.181934}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.203.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712170.183892, u'priority': 0, u'interfaceName': u'Ethernet4', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 35, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629731.184119}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.204.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:34:36.787" starttime="20181224 22:34:36.786"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>ospf_neighbors</arg>
</arguments>
<assign>
<var>@{target_neighbors}</var>
</assign>
<msg timestamp="20181224 22:34:36.787" level="INFO">@{target_neighbors} = [ 1.1.1.201 | 1.1.1.202 | 1.1.1.203 | 1.1.1.204 ]</msg>
<status status="PASS" endtime="20181224 22:34:36.787" starttime="20181224 22:34:36.787"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate OSPF Validation</arg>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Initiate OSPF Validation" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_neighbors}</var>
</assign>
<msg timestamp="20181224 22:34:36.789" level="INFO">@{established_neighbors} = [ ]</msg>
<status status="PASS" endtime="20181224 22:34:36.789" starttime="20181224 22:34:36.788"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.789" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:34:36.789" starttime="20181224 22:34:36.789"></status>
</kw>
<kw type="for" name="${cNeighbor} IN [ @{current_neighbors} ]">
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712177.177766, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.790" level="INFO">{u'inactivity': 1545712177.177766, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 2, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.178041}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.201.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:34:36.790" starttime="20181224 22:34:36.790"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:34:36.792" level="INFO">1.1.1.201 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:34:36.792" starttime="20181224 22:34:36.792"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.793" starttime="20181224 22:34:36.792"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.793" starttime="20181224 22:34:36.791"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.793" starttime="20181224 22:34:36.790"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.794" starttime="20181224 22:34:36.794"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.794" starttime="20181224 22:34:36.793"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.795" starttime="20181224 22:34:36.793"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:34:36.795" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:34:36.795" level="INFO">${established_neighbors_length} = 1</msg>
<status status="PASS" endtime="20181224 22:34:36.795" starttime="20181224 22:34:36.795"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.796" level="INFO">[u'1.1.1.201']</msg>
<status status="PASS" endtime="20181224 22:34:36.796" starttime="20181224 22:34:36.796"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.796" starttime="20181224 22:34:36.795"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.797" starttime="20181224 22:34:36.797"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.797" starttime="20181224 22:34:36.796"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.797" starttime="20181224 22:34:36.789"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712178.179529, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.798" level="INFO">{u'inactivity': 1545712178.179529, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 15, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.179747}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.202.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:34:36.798" starttime="20181224 22:34:36.798"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:34:36.800" level="INFO">1.1.1.202 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:34:36.800" starttime="20181224 22:34:36.800"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.800" starttime="20181224 22:34:36.799"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.800" starttime="20181224 22:34:36.798"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.800" starttime="20181224 22:34:36.798"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.802" starttime="20181224 22:34:36.801"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.802" starttime="20181224 22:34:36.801"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.802" starttime="20181224 22:34:36.800"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:34:36.802" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:34:36.802" level="INFO">${established_neighbors_length} = 2</msg>
<status status="PASS" endtime="20181224 22:34:36.802" starttime="20181224 22:34:36.802"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.803" level="INFO">[u'1.1.1.201', u'1.1.1.202']</msg>
<status status="PASS" endtime="20181224 22:34:36.803" starttime="20181224 22:34:36.803"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.803" starttime="20181224 22:34:36.802"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.804" starttime="20181224 22:34:36.804"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.804" starttime="20181224 22:34:36.803"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.804" starttime="20181224 22:34:36.797"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712177.181715, u'priority': 0, u'interfaceName': u'Ethernet3', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.805" level="INFO">{u'inactivity': 1545712177.181715, u'priority': 0, u'interfaceName': u'Ethernet3', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 9, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629733.181934}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.203.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:34:36.805" starttime="20181224 22:34:36.804"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:34:36.806" level="INFO">1.1.1.203 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:34:36.806" starttime="20181224 22:34:36.806"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.807" starttime="20181224 22:34:36.806"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.807" starttime="20181224 22:34:36.805"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.807" starttime="20181224 22:34:36.805"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.808" starttime="20181224 22:34:36.808"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.808" starttime="20181224 22:34:36.807"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.808" starttime="20181224 22:34:36.807"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:34:36.809" level="INFO">Length is 3</msg>
<msg timestamp="20181224 22:34:36.809" level="INFO">${established_neighbors_length} = 3</msg>
<status status="PASS" endtime="20181224 22:34:36.809" starttime="20181224 22:34:36.808"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.810" level="INFO">[u'1.1.1.201', u'1.1.1.202', u'1.1.1.203']</msg>
<status status="PASS" endtime="20181224 22:34:36.810" starttime="20181224 22:34:36.809"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.810" starttime="20181224 22:34:36.809"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.810" starttime="20181224 22:34:36.810"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.811" starttime="20181224 22:34:36.810"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.811" starttime="20181224 22:34:36.804"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712170.183892, u'priority': 0, u'interfaceName': u'Ethernet4', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.811" level="INFO">{u'inactivity': 1545712170.183892, u'priority': 0, u'interfaceName': u'Ethernet4', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 35, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629731.184119}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.204.1', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:34:36.811" starttime="20181224 22:34:36.811"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:34:36.813" level="INFO">1.1.1.204 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:34:36.813" starttime="20181224 22:34:36.813"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.813" starttime="20181224 22:34:36.812"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.813" starttime="20181224 22:34:36.812"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.813" starttime="20181224 22:34:36.811"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.814" starttime="20181224 22:34:36.814"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.815" starttime="20181224 22:34:36.814"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.815" starttime="20181224 22:34:36.813"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:34:36.815" level="INFO">Length is 4</msg>
<msg timestamp="20181224 22:34:36.815" level="INFO">${established_neighbors_length} = 4</msg>
<status status="PASS" endtime="20181224 22:34:36.815" starttime="20181224 22:34:36.815"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.816" level="INFO">[u'1.1.1.201', u'1.1.1.202', u'1.1.1.203', u'1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:34:36.816" starttime="20181224 22:34:36.816"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.816" starttime="20181224 22:34:36.815"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.817" starttime="20181224 22:34:36.816"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.817" starttime="20181224 22:34:36.816"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.817" starttime="20181224 22:34:36.811"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.817" starttime="20181224 22:34:36.789"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.817" level="INFO">[u'1.1.1.201', u'1.1.1.202', u'1.1.1.203', u'1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:34:36.817" starttime="20181224 22:34:36.817"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.818" level="INFO">['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:34:36.818" starttime="20181224 22:34:36.817"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_neighbors} ]">
<kw type="foritem" name="${listObject} = 1.1.1.201">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.819" starttime="20181224 22:34:36.818"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.819" starttime="20181224 22:34:36.818"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.819" starttime="20181224 22:34:36.818"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.202">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.820" starttime="20181224 22:34:36.820"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.820" starttime="20181224 22:34:36.819"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.820" starttime="20181224 22:34:36.819"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.203">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.821" starttime="20181224 22:34:36.820"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.821" starttime="20181224 22:34:36.820"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.821" starttime="20181224 22:34:36.820"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.204">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.822" starttime="20181224 22:34:36.821"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.822" starttime="20181224 22:34:36.821"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.822" starttime="20181224 22:34:36.821"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.822" starttime="20181224 22:34:36.818"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.822" starttime="20181224 22:34:36.788"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.822" starttime="20181224 22:34:36.787"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.822" starttime="20181224 22:34:36.368"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.822" starttime="20181224 22:34:36.366"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:36.822" starttime="20181224 22:34:35.694"></status>
</kw>
<doc>Validate OSPF Neighbors for Spines</doc>
<tags>
<tag>SPINE_OSPF</tag>
</tags>
<status status="PASS" endtime="20181224 22:34:36.822" critical="yes" starttime="20181224 22:34:35.693"></status>
</test>
<test id="s1-t3" name="Spine EVPN Peering Validation">
<kw type="for" name="${spine} IN [ @{spines} ]">
<kw type="foritem" name="${spine} = DCA-Spine1">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:36.823" starttime="20181224 22:34:36.823"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:34:36.824" level="INFO">${switch_info} = {'username': 'admin', 'index': 1, 'node': Node(connection=EapiConnection(transport=https://10.255.255.101:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine1', 'host': '10.255.255.101', 'tra...</msg>
<status status="PASS" endtime="20181224 22:34:36.824" starttime="20181224 22:34:36.824"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.824" level="INFO">{'username': 'admin', 'index': 1, 'node': Node(connection=EapiConnection(transport=https://10.255.255.101:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine1', 'host': '10.255.255.101', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.101:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:34:36.825" starttime="20181224 22:34:36.824"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.825" level="INFO">DCA-Spine1</msg>
<status status="PASS" endtime="20181224 22:34:36.825" starttime="20181224 22:34:36.825"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${spines}</arg>
<arg>${spine}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:36.825" level="INFO">${target_dictionary} = {'p2p_ping': ['10.101.201.1', '10.101.202.1', '10.101.203.1', '10.101.204.1'], 'management_ip': '10.255.255.101', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ...</msg>
<status status="PASS" endtime="20181224 22:34:36.825" starttime="20181224 22:34:36.825"></status>
</kw>
<kw name="Validate EVPN Peerings" library="Validate_EVPN_Peerings">
<doc>Validating EVPN Peerings on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${spine}</arg>
</arguments>
<kw name="Get Peers" library="Validate_EVPN_Peerings">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_peers}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show bgp evpn summary</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:34:36.827" level="INFO">${cmd} = show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:34:36.827" starttime="20181224 22:34:36.826"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:34:36.827" level="INFO">show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:34:36.827" starttime="20181224 22:34:36.827"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.868" starttime="20181224 22:34:36.828"></status>
</kw>
<msg timestamp="20181224 22:34:37.869" level="INFO">${result} = [{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.101', u'peers': {u'1.1.1.201': {u'msgSent': 7279, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629737.683906, u'vers...</msg>
<status status="PASS" endtime="20181224 22:34:37.869" starttime="20181224 22:34:36.827"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.870" level="INFO">{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.101', u'peers': {u'1.1.1.201': {u'msgSent': 7279, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629737.683906, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7259, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.202': {u'msgSent': 7237, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629743.4290245, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7232, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.203': {u'msgSent': 7335, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629731.9300294, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7259, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}, u'1.1.1.204': {u'msgSent': 7359, u'inMsgQueue': 0, u'prefixReceived': 3, u'upDownTime': 1545629743.986043, u'version': 4, u'prefixAccepted': 3, u'msgReceived': 7337, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}}, u'vrf': u'default', u'asn': 65100}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:34:37.870" starttime="20181224 22:34:37.869"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']}</arg>
<arg>peers</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:34:37.871" level="INFO">${result_dict} = {u'1.1.1.201': {u'msgSent': 7279, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629737.683906, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7259, u'peerState': u'Established', u'o...</msg>
<status status="PASS" endtime="20181224 22:34:37.871" starttime="20181224 22:34:37.870"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.871" level="INFO">{u'1.1.1.201': {u'msgSent': 7279, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629737.683906, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7259, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.202': {u'msgSent': 7237, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629743.4290245, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7232, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.203': {u'msgSent': 7335, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629731.9300294, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7259, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}, u'1.1.1.204': {u'msgSent': 7359, u'inMsgQueue': 0, u'prefixReceived': 3, u'upDownTime': 1545629743.986043, u'version': 4, u'prefixAccepted': 3, u'msgReceived': 7337, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}}</msg>
<status status="PASS" endtime="20181224 22:34:37.872" starttime="20181224 22:34:37.871"></status>
</kw>
<msg timestamp="20181224 22:34:37.872" level="INFO">${current_peers} = {u'1.1.1.201': {u'msgSent': 7279, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629737.683906, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7259, u'peerState': u'Established', u'o...</msg>
<status status="PASS" endtime="20181224 22:34:37.872" starttime="20181224 22:34:36.826"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.873" level="INFO">{u'1.1.1.201': {u'msgSent': 7279, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629737.683906, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7259, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.202': {u'msgSent': 7237, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629743.4290245, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7232, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.203': {u'msgSent': 7335, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629731.9300294, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7259, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}, u'1.1.1.204': {u'msgSent': 7359, u'inMsgQueue': 0, u'prefixReceived': 3, u'upDownTime': 1545629743.986043, u'version': 4, u'prefixAccepted': 3, u'msgReceived': 7337, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}}</msg>
<status status="PASS" endtime="20181224 22:34:37.873" starttime="20181224 22:34:37.872"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>evpn_peers</arg>
</arguments>
<assign>
<var>@{target_peers}</var>
</assign>
<msg timestamp="20181224 22:34:37.874" level="INFO">@{target_peers} = [ 1.1.1.201 | 1.1.1.202 | 1.1.1.203 | 1.1.1.204 ]</msg>
<status status="PASS" endtime="20181224 22:34:37.874" starttime="20181224 22:34:37.873"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate EVPN Validation</arg>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Initiate EVPN Validation" library="Validate_EVPN_Peerings">
<arguments>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_peers}</var>
</assign>
<msg timestamp="20181224 22:34:37.875" level="INFO">@{established_peers} = [ ]</msg>
<status status="PASS" endtime="20181224 22:34:37.876" starttime="20181224 22:34:37.875"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.876" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:34:37.876" starttime="20181224 22:34:37.876"></status>
</kw>
<kw type="for" name="${cPeer} IN [ @{current_peers} ]">
<kw type="foritem" name="${cPeer} = 1.1.1.201">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.877" level="INFO">1.1.1.201</msg>
<status status="PASS" endtime="20181224 22:34:37.877" starttime="20181224 22:34:37.877"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.877" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:34:37.878" starttime="20181224 22:34:37.877"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:34:37.879" level="INFO">1.1.1.201 is Established</msg>
<status status="PASS" endtime="20181224 22:34:37.880" starttime="20181224 22:34:37.879"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.880" starttime="20181224 22:34:37.879"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.880" starttime="20181224 22:34:37.878"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.880" starttime="20181224 22:34:37.878"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.881" starttime="20181224 22:34:37.881"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.881" starttime="20181224 22:34:37.880"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.881" starttime="20181224 22:34:37.880"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:34:37.882" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:34:37.882" level="INFO">${established_peers_length} = 1</msg>
<status status="PASS" endtime="20181224 22:34:37.882" starttime="20181224 22:34:37.882"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.883" level="INFO">[u'1.1.1.201']</msg>
<status status="PASS" endtime="20181224 22:34:37.883" starttime="20181224 22:34:37.883"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.883" starttime="20181224 22:34:37.882"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.884" starttime="20181224 22:34:37.884"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.884" starttime="20181224 22:34:37.883"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.884" starttime="20181224 22:34:37.876"></status>
</kw>
<kw type="foritem" name="${cPeer} = 1.1.1.202">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.884" level="INFO">1.1.1.202</msg>
<status status="PASS" endtime="20181224 22:34:37.885" starttime="20181224 22:34:37.884"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.885" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:34:37.885" starttime="20181224 22:34:37.885"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:34:37.887" level="INFO">1.1.1.202 is Established</msg>
<status status="PASS" endtime="20181224 22:34:37.887" starttime="20181224 22:34:37.887"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.887" starttime="20181224 22:34:37.886"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.887" starttime="20181224 22:34:37.886"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.887" starttime="20181224 22:34:37.886"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.889" starttime="20181224 22:34:37.888"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.889" starttime="20181224 22:34:37.888"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.889" starttime="20181224 22:34:37.888"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:34:37.889" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:34:37.889" level="INFO">${established_peers_length} = 2</msg>
<status status="PASS" endtime="20181224 22:34:37.889" starttime="20181224 22:34:37.889"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.890" level="INFO">[u'1.1.1.201', u'1.1.1.202']</msg>
<status status="PASS" endtime="20181224 22:34:37.890" starttime="20181224 22:34:37.890"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.890" starttime="20181224 22:34:37.890"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.891" starttime="20181224 22:34:37.891"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.891" starttime="20181224 22:34:37.890"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.891" starttime="20181224 22:34:37.884"></status>
</kw>
<kw type="foritem" name="${cPeer} = 1.1.1.203">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.892" level="INFO">1.1.1.203</msg>
<status status="PASS" endtime="20181224 22:34:37.892" starttime="20181224 22:34:37.891"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.892" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:34:37.892" starttime="20181224 22:34:37.892"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:34:37.894" level="INFO">1.1.1.203 is Established</msg>
<status status="PASS" endtime="20181224 22:34:37.894" starttime="20181224 22:34:37.893"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.894" starttime="20181224 22:34:37.893"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.894" starttime="20181224 22:34:37.893"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.894" starttime="20181224 22:34:37.892"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.895" starttime="20181224 22:34:37.895"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.895" starttime="20181224 22:34:37.894"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.895" starttime="20181224 22:34:37.894"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:34:37.896" level="INFO">Length is 3</msg>
<msg timestamp="20181224 22:34:37.896" level="INFO">${established_peers_length} = 3</msg>
<status status="PASS" endtime="20181224 22:34:37.896" starttime="20181224 22:34:37.896"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.897" level="INFO">[u'1.1.1.201', u'1.1.1.202', u'1.1.1.203']</msg>
<status status="PASS" endtime="20181224 22:34:37.897" starttime="20181224 22:34:37.896"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.897" starttime="20181224 22:34:37.896"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.897" starttime="20181224 22:34:37.897"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.898" starttime="20181224 22:34:37.897"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.898" starttime="20181224 22:34:37.891"></status>
</kw>
<kw type="foritem" name="${cPeer} = 1.1.1.204">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.898" level="INFO">1.1.1.204</msg>
<status status="PASS" endtime="20181224 22:34:37.898" starttime="20181224 22:34:37.898"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.898" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:34:37.899" starttime="20181224 22:34:37.898"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:34:37.900" level="INFO">1.1.1.204 is Established</msg>
<status status="PASS" endtime="20181224 22:34:37.900" starttime="20181224 22:34:37.900"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.900" starttime="20181224 22:34:37.900"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.900" starttime="20181224 22:34:37.899"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.900" starttime="20181224 22:34:37.899"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.902" starttime="20181224 22:34:37.901"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.902" starttime="20181224 22:34:37.901"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.902" starttime="20181224 22:34:37.901"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:34:37.902" level="INFO">Length is 4</msg>
<msg timestamp="20181224 22:34:37.902" level="INFO">${established_peers_length} = 4</msg>
<status status="PASS" endtime="20181224 22:34:37.902" starttime="20181224 22:34:37.902"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.903" level="INFO">[u'1.1.1.201', u'1.1.1.202', u'1.1.1.203', u'1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:34:37.903" starttime="20181224 22:34:37.903"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.903" starttime="20181224 22:34:37.902"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.904" starttime="20181224 22:34:37.904"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.904" starttime="20181224 22:34:37.903"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.904" starttime="20181224 22:34:37.898"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.904" starttime="20181224 22:34:37.876"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.904" level="INFO">[u'1.1.1.201', u'1.1.1.202', u'1.1.1.203', u'1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:34:37.904" starttime="20181224 22:34:37.904"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.905" level="INFO">['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:34:37.905" starttime="20181224 22:34:37.905"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_peers} ]">
<kw type="foritem" name="${listObject} = 1.1.1.201">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.906" starttime="20181224 22:34:37.906"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.906" starttime="20181224 22:34:37.905"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.906" starttime="20181224 22:34:37.905"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.202">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.907" starttime="20181224 22:34:37.906"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.907" starttime="20181224 22:34:37.906"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.907" starttime="20181224 22:34:37.906"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.203">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.908" starttime="20181224 22:34:37.907"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.908" starttime="20181224 22:34:37.907"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.908" starttime="20181224 22:34:37.907"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.204">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.909" starttime="20181224 22:34:37.908"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.909" starttime="20181224 22:34:37.908"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.909" starttime="20181224 22:34:37.908"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.909" starttime="20181224 22:34:37.905"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.909" starttime="20181224 22:34:37.875"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.909" starttime="20181224 22:34:37.874"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.909" starttime="20181224 22:34:36.826"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:37.909" starttime="20181224 22:34:36.823"></status>
</kw>
<kw type="foritem" name="${spine} = DCA-Spine2">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:37.909" starttime="20181224 22:34:37.909"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:34:37.910" level="INFO">${switch_info} = {'username': 'admin', 'index': 2, 'node': Node(connection=EapiConnection(transport=https://10.255.255.102:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine2', 'host': '10.255.255.102', 'tra...</msg>
<status status="PASS" endtime="20181224 22:34:37.910" starttime="20181224 22:34:37.910"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.910" level="INFO">{'username': 'admin', 'index': 2, 'node': Node(connection=EapiConnection(transport=https://10.255.255.102:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Spine2', 'host': '10.255.255.102', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.102:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:34:37.910" starttime="20181224 22:34:37.910"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${spine}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.911" level="INFO">DCA-Spine2</msg>
<status status="PASS" endtime="20181224 22:34:37.911" starttime="20181224 22:34:37.910"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${spines}</arg>
<arg>${spine}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:37.911" level="INFO">${target_dictionary} = {'p2p_ping': ['10.102.201.1', '10.102.202.1', '10.102.203.1', '10.102.204.1'], 'management_ip': '10.255.255.102', 'evpn_peers': ['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204'], 'ospf_neighbors': ...</msg>
<status status="PASS" endtime="20181224 22:34:37.911" starttime="20181224 22:34:37.911"></status>
</kw>
<kw name="Validate EVPN Peerings" library="Validate_EVPN_Peerings">
<doc>Validating EVPN Peerings on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${spine}</arg>
</arguments>
<kw name="Get Peers" library="Validate_EVPN_Peerings">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_peers}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show bgp evpn summary</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:34:37.912" level="INFO">${cmd} = show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:34:37.912" starttime="20181224 22:34:37.912"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:34:37.913" level="INFO">show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:34:37.913" starttime="20181224 22:34:37.912"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.960" starttime="20181224 22:34:37.913"></status>
</kw>
<msg timestamp="20181224 22:34:38.960" level="INFO">${result} = [{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.102', u'peers': {u'1.1.1.201': {u'msgSent': 7267, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629740.6284666, u'ver...</msg>
<status status="PASS" endtime="20181224 22:34:38.960" starttime="20181224 22:34:37.913"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.961" level="INFO">{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.102', u'peers': {u'1.1.1.201': {u'msgSent': 7267, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629740.6284666, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7256, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.202': {u'msgSent': 7260, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629741.4733386, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7240, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.203': {u'msgSent': 7380, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629737.3675945, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7324, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}, u'1.1.1.204': {u'msgSent': 7387, u'inMsgQueue': 0, u'prefixReceived': 3, u'upDownTime': 1545629742.173846, u'version': 4, u'prefixAccepted': 3, u'msgReceived': 7239, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}}, u'vrf': u'default', u'asn': 65100}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:34:38.961" starttime="20181224 22:34:38.960"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']}</arg>
<arg>peers</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:34:38.962" level="INFO">${result_dict} = {u'1.1.1.201': {u'msgSent': 7267, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629740.6284666, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7256, u'peerState': u'Established', u'...</msg>
<status status="PASS" endtime="20181224 22:34:38.962" starttime="20181224 22:34:38.961"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.962" level="INFO">{u'1.1.1.201': {u'msgSent': 7267, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629740.6284666, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7256, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.202': {u'msgSent': 7260, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629741.4733386, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7240, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.203': {u'msgSent': 7380, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629737.3675945, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7324, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}, u'1.1.1.204': {u'msgSent': 7387, u'inMsgQueue': 0, u'prefixReceived': 3, u'upDownTime': 1545629742.173846, u'version': 4, u'prefixAccepted': 3, u'msgReceived': 7239, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}}</msg>
<status status="PASS" endtime="20181224 22:34:38.963" starttime="20181224 22:34:38.962"></status>
</kw>
<msg timestamp="20181224 22:34:38.963" level="INFO">${current_peers} = {u'1.1.1.201': {u'msgSent': 7267, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629740.6284666, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7256, u'peerState': u'Established', u'...</msg>
<status status="PASS" endtime="20181224 22:34:38.963" starttime="20181224 22:34:37.912"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.964" level="INFO">{u'1.1.1.201': {u'msgSent': 7267, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629740.6284666, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7256, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.202': {u'msgSent': 7260, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629741.4733386, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7240, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65101}, u'1.1.1.203': {u'msgSent': 7380, u'inMsgQueue': 0, u'prefixReceived': 5, u'upDownTime': 1545629737.3675945, u'version': 4, u'prefixAccepted': 5, u'msgReceived': 7324, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}, u'1.1.1.204': {u'msgSent': 7387, u'inMsgQueue': 0, u'prefixReceived': 3, u'upDownTime': 1545629742.173846, u'version': 4, u'prefixAccepted': 3, u'msgReceived': 7239, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65102}}</msg>
<status status="PASS" endtime="20181224 22:34:38.964" starttime="20181224 22:34:38.963"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>evpn_peers</arg>
</arguments>
<assign>
<var>@{target_peers}</var>
</assign>
<msg timestamp="20181224 22:34:38.964" level="INFO">@{target_peers} = [ 1.1.1.201 | 1.1.1.202 | 1.1.1.203 | 1.1.1.204 ]</msg>
<status status="PASS" endtime="20181224 22:34:38.964" starttime="20181224 22:34:38.964"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate EVPN Validation</arg>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Initiate EVPN Validation" library="Validate_EVPN_Peerings">
<arguments>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_peers}</var>
</assign>
<msg timestamp="20181224 22:34:38.966" level="INFO">@{established_peers} = [ ]</msg>
<status status="PASS" endtime="20181224 22:34:38.966" starttime="20181224 22:34:38.966"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.967" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:34:38.967" starttime="20181224 22:34:38.966"></status>
</kw>
<kw type="for" name="${cPeer} IN [ @{current_peers} ]">
<kw type="foritem" name="${cPeer} = 1.1.1.201">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.968" level="INFO">1.1.1.201</msg>
<status status="PASS" endtime="20181224 22:34:38.968" starttime="20181224 22:34:38.967"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.968" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:34:38.968" starttime="20181224 22:34:38.968"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:34:38.970" level="INFO">1.1.1.201 is Established</msg>
<status status="PASS" endtime="20181224 22:34:38.970" starttime="20181224 22:34:38.970"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.970" starttime="20181224 22:34:38.970"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.971" starttime="20181224 22:34:38.969"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.971" starttime="20181224 22:34:38.968"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.972" starttime="20181224 22:34:38.972"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.972" starttime="20181224 22:34:38.971"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.972" starttime="20181224 22:34:38.971"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:34:38.973" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:34:38.973" level="INFO">${established_peers_length} = 1</msg>
<status status="PASS" endtime="20181224 22:34:38.973" starttime="20181224 22:34:38.973"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.974" level="INFO">[u'1.1.1.201']</msg>
<status status="PASS" endtime="20181224 22:34:38.974" starttime="20181224 22:34:38.974"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.974" starttime="20181224 22:34:38.973"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.975" starttime="20181224 22:34:38.974"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.975" starttime="20181224 22:34:38.974"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.975" starttime="20181224 22:34:38.967"></status>
</kw>
<kw type="foritem" name="${cPeer} = 1.1.1.202">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.975" level="INFO">1.1.1.202</msg>
<status status="PASS" endtime="20181224 22:34:38.975" starttime="20181224 22:34:38.975"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.976" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:34:38.976" starttime="20181224 22:34:38.976"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:34:38.978" level="INFO">1.1.1.202 is Established</msg>
<status status="PASS" endtime="20181224 22:34:38.978" starttime="20181224 22:34:38.978"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.978" starttime="20181224 22:34:38.977"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.978" starttime="20181224 22:34:38.977"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.978" starttime="20181224 22:34:38.976"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.980" starttime="20181224 22:34:38.979"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.980" starttime="20181224 22:34:38.979"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.980" starttime="20181224 22:34:38.978"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:34:38.980" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:34:38.980" level="INFO">${established_peers_length} = 2</msg>
<status status="PASS" endtime="20181224 22:34:38.980" starttime="20181224 22:34:38.980"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.981" level="INFO">[u'1.1.1.201', u'1.1.1.202']</msg>
<status status="PASS" endtime="20181224 22:34:38.981" starttime="20181224 22:34:38.981"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.981" starttime="20181224 22:34:38.980"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.982" starttime="20181224 22:34:38.982"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.982" starttime="20181224 22:34:38.981"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.982" starttime="20181224 22:34:38.975"></status>
</kw>
<kw type="foritem" name="${cPeer} = 1.1.1.203">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.983" level="INFO">1.1.1.203</msg>
<status status="PASS" endtime="20181224 22:34:38.983" starttime="20181224 22:34:38.982"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.983" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:34:38.983" starttime="20181224 22:34:38.983"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:34:38.985" level="INFO">1.1.1.203 is Established</msg>
<status status="PASS" endtime="20181224 22:34:38.985" starttime="20181224 22:34:38.985"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.985" starttime="20181224 22:34:38.984"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.985" starttime="20181224 22:34:38.984"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.985" starttime="20181224 22:34:38.983"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.986" starttime="20181224 22:34:38.986"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.986" starttime="20181224 22:34:38.986"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.986" starttime="20181224 22:34:38.985"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:34:38.987" level="INFO">Length is 3</msg>
<msg timestamp="20181224 22:34:38.987" level="INFO">${established_peers_length} = 3</msg>
<status status="PASS" endtime="20181224 22:34:38.987" starttime="20181224 22:34:38.987"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.988" level="INFO">[u'1.1.1.201', u'1.1.1.202', u'1.1.1.203']</msg>
<status status="PASS" endtime="20181224 22:34:38.988" starttime="20181224 22:34:38.987"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.988" starttime="20181224 22:34:38.987"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.988" starttime="20181224 22:34:38.988"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.989" starttime="20181224 22:34:38.988"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.989" starttime="20181224 22:34:38.982"></status>
</kw>
<kw type="foritem" name="${cPeer} = 1.1.1.204">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.989" level="INFO">1.1.1.204</msg>
<status status="PASS" endtime="20181224 22:34:38.989" starttime="20181224 22:34:38.989"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.990" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:34:38.990" starttime="20181224 22:34:38.989"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:34:38.991" level="INFO">1.1.1.204 is Established</msg>
<status status="PASS" endtime="20181224 22:34:38.991" starttime="20181224 22:34:38.991"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.991" starttime="20181224 22:34:38.991"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.991" starttime="20181224 22:34:38.990"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.991" starttime="20181224 22:34:38.990"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.993" starttime="20181224 22:34:38.992"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.993" starttime="20181224 22:34:38.992"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.993" starttime="20181224 22:34:38.992"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:34:38.993" level="INFO">Length is 4</msg>
<msg timestamp="20181224 22:34:38.993" level="INFO">${established_peers_length} = 4</msg>
<status status="PASS" endtime="20181224 22:34:38.993" starttime="20181224 22:34:38.993"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.994" level="INFO">[u'1.1.1.201', u'1.1.1.202', u'1.1.1.203', u'1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:34:38.994" starttime="20181224 22:34:38.994"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.994" starttime="20181224 22:34:38.993"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.995" starttime="20181224 22:34:38.994"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.995" starttime="20181224 22:34:38.994"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.995" starttime="20181224 22:34:38.989"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.995" starttime="20181224 22:34:38.967"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.995" level="INFO">[u'1.1.1.201', u'1.1.1.202', u'1.1.1.203', u'1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:34:38.995" starttime="20181224 22:34:38.995"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_peers}</arg>
</arguments>
<msg timestamp="20181224 22:34:38.996" level="INFO">['1.1.1.201', '1.1.1.202', '1.1.1.203', '1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:34:38.996" starttime="20181224 22:34:38.995"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_peers} ]">
<kw type="foritem" name="${listObject} = 1.1.1.201">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.997" starttime="20181224 22:34:38.996"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.997" starttime="20181224 22:34:38.996"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.997" starttime="20181224 22:34:38.996"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.202">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.998" starttime="20181224 22:34:38.998"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.998" starttime="20181224 22:34:38.997"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.998" starttime="20181224 22:34:38.997"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.203">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:38.999" starttime="20181224 22:34:38.998"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.999" starttime="20181224 22:34:38.998"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:38.999" starttime="20181224 22:34:38.998"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.204">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:39.000" starttime="20181224 22:34:38.999"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:39.000" starttime="20181224 22:34:38.999"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:39.000" starttime="20181224 22:34:38.999"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:39.000" starttime="20181224 22:34:38.996"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:39.000" starttime="20181224 22:34:38.965"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:39.000" starttime="20181224 22:34:38.965"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:39.000" starttime="20181224 22:34:37.911"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:39.000" starttime="20181224 22:34:37.909"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:39.000" starttime="20181224 22:34:36.823"></status>
</kw>
<doc>Validate EVPN Peerings for Spines</doc>
<tags>
<tag>SPINE_EVPN</tag>
</tags>
<status status="PASS" endtime="20181224 22:34:39.000" critical="yes" starttime="20181224 22:34:36.823"></status>
</test>
<test id="s1-t4" name="Leaf Ping Tests">
<kw type="for" name="${leaf} IN [ @{leafs} ]">
<kw type="foritem" name="${leaf} = DCA-BL2">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:39.001" starttime="20181224 22:34:39.001"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:34:39.002" level="INFO">${switch_info} = {'username': 'admin', 'index': 3, 'node': Node(connection=EapiConnection(transport=https://10.255.255.204:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL2', 'host': '10.255.255.204', 'transp...</msg>
<status status="PASS" endtime="20181224 22:34:39.002" starttime="20181224 22:34:39.002"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:34:39.002" level="INFO">{'username': 'admin', 'index': 3, 'node': Node(connection=EapiConnection(transport=https://10.255.255.204:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL2', 'host': '10.255.255.204', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.204:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:34:39.002" starttime="20181224 22:34:39.002"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:39.003" level="INFO">DCA-BL2</msg>
<status status="PASS" endtime="20181224 22:34:39.003" starttime="20181224 22:34:39.002"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:39.003" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.204', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.203'], 'loopback': '1.1.1.204'}</msg>
<status status="PASS" endtime="20181224 22:34:39.003" starttime="20181224 22:34:39.003"></status>
</kw>
<kw name="Initiate All Leaf Ping Tests" library="Ping_All">
<doc>Running all Ping Tests on Leafs</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<kw name="Ping Leaf Loopbacks" library="Ping_Loopbacks">
<kw type="for" name="${loopback} IN [ @{loopback_ping} ]">
<kw type="foritem" name="${loopback} = 1.1.1.101">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:39.004" level="INFO">1.1.1.101</msg>
<status status="PASS" endtime="20181224 22:34:39.004" starttime="20181224 22:34:39.004"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:39.886" level="INFO">${output} = [{'command': 'ping 1.1.1.101', 'result': {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=142 ms\n80 bytes from 1.1.1.101: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:39.886" starttime="20181224 22:34:39.005"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:39.887" level="INFO">${result} = {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=142 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=64 time=157 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:39.887" starttime="20181224 22:34:39.886"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:39.887" level="INFO">{u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=142 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=64 time=157 ms\n80 bytes from 1.1.1.101: icmp_seq=3 ttl=64 time=173 ms\n80 bytes from 1.1.1.101: icmp_seq=4 ttl=64 time=189 ms\n80 bytes from 1.1.1.101: icmp_seq=5 ttl=64 time=209 ms\n\n--- 1.1.1.101 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 142.747/174.744/209.817/23.558 ms, pipe 5, ipg/ewma 11.189/160.488 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:39.888" starttime="20181224 22:34:39.887"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:39.888" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:39.889" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:39.889" starttime="20181224 22:34:39.888"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:39.889" starttime="20181224 22:34:39.889"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:39.889" starttime="20181224 22:34:39.005"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:39.890" starttime="20181224 22:34:39.004"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:39.890" starttime="20181224 22:34:39.004"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.102">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:39.890" level="INFO">1.1.1.102</msg>
<status status="PASS" endtime="20181224 22:34:39.890" starttime="20181224 22:34:39.890"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:40.628" level="INFO">${output} = [{'command': 'ping 1.1.1.102', 'result': {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=146 ms\n80 bytes from 1.1.1.102: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:40.628" starttime="20181224 22:34:39.891"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:40.629" level="INFO">${result} = {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=146 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=64 time=159 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:40.629" starttime="20181224 22:34:40.628"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:40.630" level="INFO">{u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=146 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=64 time=159 ms\n80 bytes from 1.1.1.102: icmp_seq=3 ttl=64 time=177 ms\n80 bytes from 1.1.1.102: icmp_seq=4 ttl=64 time=194 ms\n80 bytes from 1.1.1.102: icmp_seq=5 ttl=64 time=212 ms\n\n--- 1.1.1.102 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 146.188/178.030/212.691/23.767 ms, pipe 5, ipg/ewma 11.110/163.872 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:40.630" starttime="20181224 22:34:40.629"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:40.631" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:40.631" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:40.631" starttime="20181224 22:34:40.630"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:40.632" starttime="20181224 22:34:40.631"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:40.632" starttime="20181224 22:34:39.891"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:40.632" starttime="20181224 22:34:39.890"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:40.632" starttime="20181224 22:34:39.890"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.201">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:40.633" level="INFO">1.1.1.201</msg>
<status status="PASS" endtime="20181224 22:34:40.633" starttime="20181224 22:34:40.632"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:41.695" level="INFO">${output} = [{'command': 'ping 1.1.1.201', 'result': {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=63 time=204 ms\n80 bytes from 1.1.1.201: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:41.695" starttime="20181224 22:34:40.634"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:41.696" level="INFO">${result} = {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=63 time=204 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=63 time=448 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:41.696" starttime="20181224 22:34:41.696"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:41.697" level="INFO">{u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=63 time=204 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=63 time=448 ms\n80 bytes from 1.1.1.201: icmp_seq=3 ttl=63 time=468 ms\n80 bytes from 1.1.1.201: icmp_seq=4 ttl=63 time=486 ms\n80 bytes from 1.1.1.201: icmp_seq=5 ttl=63 time=504 ms\n\n--- 1.1.1.201 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 47ms\nrtt min/avg/max/mdev = 204.055/422.623/504.570/110.838 ms, pipe 5, ipg/ewma 11.829/318.382 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:41.697" starttime="20181224 22:34:41.697"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:41.698" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:41.698" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:41.698" starttime="20181224 22:34:41.698"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:41.699" starttime="20181224 22:34:41.698"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:41.699" starttime="20181224 22:34:40.633"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:41.699" starttime="20181224 22:34:40.633"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:41.699" starttime="20181224 22:34:40.632"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.202">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:41.700" level="INFO">1.1.1.202</msg>
<status status="PASS" endtime="20181224 22:34:41.700" starttime="20181224 22:34:41.699"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:42.737" level="INFO">${output} = [{'command': 'ping 1.1.1.202', 'result': {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=63 time=414 ms\n80 bytes from 1.1.1.202: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:42.737" starttime="20181224 22:34:41.701"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:42.738" level="INFO">${result} = {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=63 time=414 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=63 time=425 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:42.738" starttime="20181224 22:34:42.737"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:42.739" level="INFO">{u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=63 time=414 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=63 time=425 ms\n80 bytes from 1.1.1.202: icmp_seq=3 ttl=63 time=443 ms\n80 bytes from 1.1.1.202: icmp_seq=4 ttl=63 time=460 ms\n80 bytes from 1.1.1.202: icmp_seq=5 ttl=63 time=478 ms\n\n--- 1.1.1.202 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 414.856/444.604/478.610/23.127 ms, pipe 5, ipg/ewma 11.581/431.460 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:42.739" starttime="20181224 22:34:42.738"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:42.740" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:42.740" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:42.740" starttime="20181224 22:34:42.739"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:42.740" starttime="20181224 22:34:42.740"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:42.741" starttime="20181224 22:34:41.700"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:42.741" starttime="20181224 22:34:41.700"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:42.741" starttime="20181224 22:34:41.699"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.203">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:42.741" level="INFO">1.1.1.203</msg>
<status status="PASS" endtime="20181224 22:34:42.741" starttime="20181224 22:34:42.741"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:43.684" level="INFO">${output} = [{'command': 'ping 1.1.1.203', 'result': {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=240 ms\n80 bytes from 1.1.1.203: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:43.684" starttime="20181224 22:34:42.742"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:43.685" level="INFO">${result} = {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=240 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=64 time=263 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:43.685" starttime="20181224 22:34:43.685"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:43.686" level="INFO">{u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=240 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=64 time=263 ms\n80 bytes from 1.1.1.203: icmp_seq=3 ttl=64 time=288 ms\n80 bytes from 1.1.1.203: icmp_seq=4 ttl=64 time=309 ms\n80 bytes from 1.1.1.203: icmp_seq=5 ttl=64 time=332 ms\n\n--- 1.1.1.203 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 40ms\nrtt min/avg/max/mdev = 240.159/286.911/332.383/32.563 ms, pipe 5, ipg/ewma 10.138/265.898 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:43.686" starttime="20181224 22:34:43.686"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:43.687" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:43.687" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:43.687" starttime="20181224 22:34:43.686"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:43.688" starttime="20181224 22:34:43.687"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:43.688" starttime="20181224 22:34:42.742"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:43.688" starttime="20181224 22:34:42.742"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:43.688" starttime="20181224 22:34:42.741"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.204">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:43.689" level="INFO">1.1.1.204</msg>
<status status="PASS" endtime="20181224 22:34:43.689" starttime="20181224 22:34:43.688"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:44.271" level="INFO">${output} = [{'command': 'ping 1.1.1.204', 'result': {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=0.085 ms\n80 bytes from 1.1.1.204: icmp_seq...</msg>
<status status="PASS" endtime="20181224 22:34:44.271" starttime="20181224 22:34:43.690"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:44.272" level="INFO">${result} = {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=0.085 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=64 time=0.040 ms\n80 bytes from 1....</msg>
<status status="PASS" endtime="20181224 22:34:44.272" starttime="20181224 22:34:44.271"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:44.272" level="INFO">{u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=0.085 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=64 time=0.040 ms\n80 bytes from 1.1.1.204: icmp_seq=3 ttl=64 time=0.027 ms\n80 bytes from 1.1.1.204: icmp_seq=4 ttl=64 time=0.024 ms\n80 bytes from 1.1.1.204: icmp_seq=5 ttl=64 time=0.024 ms\n\n--- 1.1.1.204 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.024/0.040/0.085/0.023 ms, ipg/ewma 0.109/0.061 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:44.273" starttime="20181224 22:34:44.272"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:44.273" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:44.273" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:44.273" starttime="20181224 22:34:44.273"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:44.274" starttime="20181224 22:34:44.274"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:44.274" starttime="20181224 22:34:43.689"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:44.274" starttime="20181224 22:34:43.689"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:44.274" starttime="20181224 22:34:43.688"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.1">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:44.275" level="INFO">2.2.2.1</msg>
<status status="PASS" endtime="20181224 22:34:44.275" starttime="20181224 22:34:44.275"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:44.917" level="INFO">${output} = [{'command': 'ping 2.2.2.1', 'result': {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=63 time=82.7 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=63 t...</msg>
<status status="PASS" endtime="20181224 22:34:44.917" starttime="20181224 22:34:44.276"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:44.918" level="INFO">${result} = {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=63 time=82.7 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=63 time=170 ms\n80 bytes from 2.2.2.1: icmp...</msg>
<status status="PASS" endtime="20181224 22:34:44.918" starttime="20181224 22:34:44.918"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:44.919" level="INFO">{u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=63 time=82.7 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=63 time=170 ms\n80 bytes from 2.2.2.1: icmp_seq=3 ttl=63 time=174 ms\n80 bytes from 2.2.2.1: icmp_seq=4 ttl=63 time=176 ms\n80 bytes from 2.2.2.1: icmp_seq=5 ttl=63 time=178 ms\n\n--- 2.2.2.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 82.769/156.436/178.297/36.934 ms, pipe 5, ipg/ewma 11.248/121.055 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:44.919" starttime="20181224 22:34:44.919"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:44.920" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:44.920" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:44.920" starttime="20181224 22:34:44.919"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:44.921" starttime="20181224 22:34:44.920"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:44.921" starttime="20181224 22:34:44.276"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:44.921" starttime="20181224 22:34:44.275"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:44.921" starttime="20181224 22:34:44.275"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.2">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:44.922" level="INFO">2.2.2.2</msg>
<status status="PASS" endtime="20181224 22:34:44.922" starttime="20181224 22:34:44.921"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:45.361" level="INFO">${output} = [{'command': 'ping 2.2.2.2', 'result': {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=0.045 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 ...</msg>
<status status="PASS" endtime="20181224 22:34:45.361" starttime="20181224 22:34:44.923"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:45.362" level="INFO">${result} = {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=0.045 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 time=0.013 ms\n80 bytes from 2.2.2.2: i...</msg>
<status status="PASS" endtime="20181224 22:34:45.362" starttime="20181224 22:34:45.362"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:45.363" level="INFO">{u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=0.045 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 time=0.013 ms\n80 bytes from 2.2.2.2: icmp_seq=3 ttl=64 time=0.010 ms\n80 bytes from 2.2.2.2: icmp_seq=4 ttl=64 time=0.010 ms\n80 bytes from 2.2.2.2: icmp_seq=5 ttl=64 time=0.009 ms\n\n--- 2.2.2.2 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.009/0.017/0.045/0.014 ms, ipg/ewma 0.038/0.030 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:45.363" starttime="20181224 22:34:45.363"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:45.364" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:45.364" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:45.364" starttime="20181224 22:34:45.363"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:45.365" starttime="20181224 22:34:45.364"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:45.365" starttime="20181224 22:34:44.922"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:45.365" starttime="20181224 22:34:44.922"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:45.365" starttime="20181224 22:34:44.921"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:45.365" starttime="20181224 22:34:39.004"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:45.365" starttime="20181224 22:34:39.003"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:45.365" starttime="20181224 22:34:39.003"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:45.365" starttime="20181224 22:34:39.001"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-BL1">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:45.366" starttime="20181224 22:34:45.366"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:34:45.366" level="INFO">${switch_info} = {'username': 'admin', 'index': 4, 'node': Node(connection=EapiConnection(transport=https://10.255.255.203:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL1', 'host': '10.255.255.203', 'transp...</msg>
<status status="PASS" endtime="20181224 22:34:45.367" starttime="20181224 22:34:45.366"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:34:45.367" level="INFO">{'username': 'admin', 'index': 4, 'node': Node(connection=EapiConnection(transport=https://10.255.255.203:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL1', 'host': '10.255.255.203', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.203:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:34:45.367" starttime="20181224 22:34:45.367"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:45.368" level="INFO">DCA-BL1</msg>
<status status="PASS" endtime="20181224 22:34:45.368" starttime="20181224 22:34:45.367"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:45.368" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.203', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.204'], 'loopback': '1.1.1.203'}</msg>
<status status="PASS" endtime="20181224 22:34:45.368" starttime="20181224 22:34:45.368"></status>
</kw>
<kw name="Initiate All Leaf Ping Tests" library="Ping_All">
<doc>Running all Ping Tests on Leafs</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<kw name="Ping Leaf Loopbacks" library="Ping_Loopbacks">
<kw type="for" name="${loopback} IN [ @{loopback_ping} ]">
<kw type="foritem" name="${loopback} = 1.1.1.101">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:45.370" level="INFO">1.1.1.101</msg>
<status status="PASS" endtime="20181224 22:34:45.370" starttime="20181224 22:34:45.370"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:46.177" level="INFO">${output} = [{'command': 'ping 1.1.1.101', 'result': {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=147 ms\n80 bytes from 1.1.1.101: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:46.178" starttime="20181224 22:34:45.371"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:46.179" level="INFO">${result} = {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=147 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=64 time=161 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:46.179" starttime="20181224 22:34:46.178"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:46.179" level="INFO">{u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=147 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=64 time=161 ms\n80 bytes from 1.1.1.101: icmp_seq=3 ttl=64 time=178 ms\n80 bytes from 1.1.1.101: icmp_seq=4 ttl=64 time=199 ms\n80 bytes from 1.1.1.101: icmp_seq=5 ttl=64 time=217 ms\n\n--- 1.1.1.101 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 45ms\nrtt min/avg/max/mdev = 147.586/180.718/217.067/25.122 ms, pipe 5, ipg/ewma 11.458/166.021 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:46.179" starttime="20181224 22:34:46.179"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:46.180" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:46.180" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:46.180" starttime="20181224 22:34:46.180"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:46.181" starttime="20181224 22:34:46.181"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:46.181" starttime="20181224 22:34:45.370"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:46.181" starttime="20181224 22:34:45.370"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:46.181" starttime="20181224 22:34:45.369"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.102">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:46.182" level="INFO">1.1.1.102</msg>
<status status="PASS" endtime="20181224 22:34:46.182" starttime="20181224 22:34:46.182"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:46.950" level="INFO">${output} = [{'command': 'ping 1.1.1.102', 'result': {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=174 ms\n80 bytes from 1.1.1.102: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:46.950" starttime="20181224 22:34:46.183"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:46.951" level="INFO">${result} = {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=174 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=64 time=190 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:46.951" starttime="20181224 22:34:46.950"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:46.952" level="INFO">{u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=174 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=64 time=190 ms\n80 bytes from 1.1.1.102: icmp_seq=3 ttl=64 time=211 ms\n80 bytes from 1.1.1.102: icmp_seq=4 ttl=64 time=231 ms\n80 bytes from 1.1.1.102: icmp_seq=5 ttl=64 time=249 ms\n\n--- 1.1.1.102 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 45ms\nrtt min/avg/max/mdev = 174.529/211.624/249.867/27.155 ms, pipe 5, ipg/ewma 11.370/195.076 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:46.952" starttime="20181224 22:34:46.951"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:46.953" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:46.953" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:46.953" starttime="20181224 22:34:46.952"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:46.953" starttime="20181224 22:34:46.953"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:46.954" starttime="20181224 22:34:46.183"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:46.954" starttime="20181224 22:34:46.182"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:46.954" starttime="20181224 22:34:46.181"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.201">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:46.954" level="INFO">1.1.1.201</msg>
<status status="PASS" endtime="20181224 22:34:46.954" starttime="20181224 22:34:46.954"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:47.997" level="INFO">${output} = [{'command': 'ping 1.1.1.201', 'result': {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=63 time=430 ms\n80 bytes from 1.1.1.201: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:47.997" starttime="20181224 22:34:46.955"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:47.998" level="INFO">${result} = {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=63 time=430 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=63 time=445 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:47.998" starttime="20181224 22:34:47.997"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:47.998" level="INFO">{u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=63 time=430 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=63 time=445 ms\n80 bytes from 1.1.1.201: icmp_seq=3 ttl=63 time=461 ms\n80 bytes from 1.1.1.201: icmp_seq=4 ttl=63 time=478 ms\n80 bytes from 1.1.1.201: icmp_seq=5 ttl=63 time=494 ms\n\n--- 1.1.1.201 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 430.096/461.951/494.852/23.060 ms, pipe 5, ipg/ewma 11.136/447.719 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:47.999" starttime="20181224 22:34:47.998"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:47.999" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:47.999" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:47.999" starttime="20181224 22:34:47.999"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:48.000" starttime="20181224 22:34:48.000"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:48.000" starttime="20181224 22:34:46.955"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:48.000" starttime="20181224 22:34:46.955"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:48.000" starttime="20181224 22:34:46.954"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.202">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:48.001" level="INFO">1.1.1.202</msg>
<status status="PASS" endtime="20181224 22:34:48.001" starttime="20181224 22:34:48.001"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:49.016" level="INFO">${output} = [{'command': 'ping 1.1.1.202', 'result': {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=63 time=420 ms\n80 bytes from 1.1.1.202: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:49.016" starttime="20181224 22:34:48.002"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:49.017" level="INFO">${result} = {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=63 time=420 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=63 time=434 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:49.017" starttime="20181224 22:34:49.016"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:49.017" level="INFO">{u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=63 time=420 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=63 time=434 ms\n80 bytes from 1.1.1.202: icmp_seq=3 ttl=63 time=452 ms\n80 bytes from 1.1.1.202: icmp_seq=4 ttl=63 time=470 ms\n80 bytes from 1.1.1.202: icmp_seq=5 ttl=63 time=488 ms\n\n--- 1.1.1.202 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 420.953/453.314/488.044/24.133 ms, pipe 5, ipg/ewma 11.547/438.922 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:49.018" starttime="20181224 22:34:49.017"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:49.018" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:49.018" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:49.018" starttime="20181224 22:34:49.018"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:49.019" starttime="20181224 22:34:49.019"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:49.019" starttime="20181224 22:34:48.002"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:49.019" starttime="20181224 22:34:48.001"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:49.020" starttime="20181224 22:34:48.001"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.203">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:49.020" level="INFO">1.1.1.203</msg>
<status status="PASS" endtime="20181224 22:34:49.020" starttime="20181224 22:34:49.020"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:49.526" level="INFO">${output} = [{'command': 'ping 1.1.1.203', 'result': {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=0.070 ms\n80 bytes from 1.1.1.203: icmp_seq...</msg>
<status status="PASS" endtime="20181224 22:34:49.526" starttime="20181224 22:34:49.021"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:49.527" level="INFO">${result} = {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=0.070 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=64 time=0.039 ms\n80 bytes from 1....</msg>
<status status="PASS" endtime="20181224 22:34:49.527" starttime="20181224 22:34:49.526"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:49.528" level="INFO">{u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=64 time=0.070 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=64 time=0.039 ms\n80 bytes from 1.1.1.203: icmp_seq=3 ttl=64 time=0.027 ms\n80 bytes from 1.1.1.203: icmp_seq=4 ttl=64 time=0.024 ms\n80 bytes from 1.1.1.203: icmp_seq=5 ttl=64 time=0.024 ms\n\n--- 1.1.1.203 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.024/0.036/0.070/0.019 ms, ipg/ewma 0.100/0.052 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:49.528" starttime="20181224 22:34:49.527"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:49.529" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:49.529" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:49.529" starttime="20181224 22:34:49.528"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:49.529" starttime="20181224 22:34:49.529"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:49.530" starttime="20181224 22:34:49.021"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:49.530" starttime="20181224 22:34:49.020"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:49.530" starttime="20181224 22:34:49.020"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.204">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:49.530" level="INFO">1.1.1.204</msg>
<status status="PASS" endtime="20181224 22:34:49.531" starttime="20181224 22:34:49.530"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:50.431" level="INFO">${output} = [{'command': 'ping 1.1.1.204', 'result': {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=266 ms\n80 bytes from 1.1.1.204: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:50.431" starttime="20181224 22:34:49.532"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:50.432" level="INFO">${result} = {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=266 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=64 time=283 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:50.432" starttime="20181224 22:34:50.431"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:50.432" level="INFO">{u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=64 time=266 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=64 time=283 ms\n80 bytes from 1.1.1.204: icmp_seq=3 ttl=64 time=305 ms\n80 bytes from 1.1.1.204: icmp_seq=4 ttl=64 time=328 ms\n80 bytes from 1.1.1.204: icmp_seq=5 ttl=64 time=350 ms\n\n--- 1.1.1.204 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 266.330/307.026/350.637/30.260 ms, pipe 5, ipg/ewma 11.068/288.919 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:50.433" starttime="20181224 22:34:50.432"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:50.433" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:50.434" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:50.434" starttime="20181224 22:34:50.433"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:50.434" starttime="20181224 22:34:50.434"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:50.435" starttime="20181224 22:34:49.531"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:50.435" starttime="20181224 22:34:49.531"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:50.435" starttime="20181224 22:34:49.530"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.1">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:50.435" level="INFO">2.2.2.1</msg>
<status status="PASS" endtime="20181224 22:34:50.435" starttime="20181224 22:34:50.435"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:51.515" level="INFO">${output} = [{'command': 'ping 2.2.2.1', 'result': {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=63 time=457 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=63 ti...</msg>
<status status="PASS" endtime="20181224 22:34:51.515" starttime="20181224 22:34:50.436"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:51.516" level="INFO">${result} = {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=63 time=457 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=63 time=469 ms\n80 bytes from 2.2.2.1: icmp_...</msg>
<status status="PASS" endtime="20181224 22:34:51.517" starttime="20181224 22:34:51.516"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:51.517" level="INFO">{u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=63 time=457 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=63 time=469 ms\n80 bytes from 2.2.2.1: icmp_seq=3 ttl=63 time=486 ms\n80 bytes from 2.2.2.1: icmp_seq=4 ttl=63 time=504 ms\n80 bytes from 2.2.2.1: icmp_seq=5 ttl=63 time=522 ms\n\n--- 2.2.2.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 457.261/488.003/522.734/23.505 ms, pipe 5, ipg/ewma 11.642/474.385 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:51.517" starttime="20181224 22:34:51.517"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:51.518" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:51.518" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:51.518" starttime="20181224 22:34:51.518"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:51.519" starttime="20181224 22:34:51.518"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:51.519" starttime="20181224 22:34:50.436"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:51.519" starttime="20181224 22:34:50.436"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:51.519" starttime="20181224 22:34:50.435"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.2">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:51.520" level="INFO">2.2.2.2</msg>
<status status="PASS" endtime="20181224 22:34:51.520" starttime="20181224 22:34:51.520"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:52.025" level="INFO">${output} = [{'command': 'ping 2.2.2.2', 'result': {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=0.071 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 ...</msg>
<status status="PASS" endtime="20181224 22:34:52.025" starttime="20181224 22:34:51.521"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:52.026" level="INFO">${result} = {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=0.071 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 time=0.030 ms\n80 bytes from 2.2.2.2: i...</msg>
<status status="PASS" endtime="20181224 22:34:52.026" starttime="20181224 22:34:52.025"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:52.027" level="INFO">{u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=64 time=0.071 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=64 time=0.030 ms\n80 bytes from 2.2.2.2: icmp_seq=3 ttl=64 time=0.023 ms\n80 bytes from 2.2.2.2: icmp_seq=4 ttl=64 time=0.022 ms\n80 bytes from 2.2.2.2: icmp_seq=5 ttl=64 time=0.023 ms\n\n--- 2.2.2.2 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.022/0.033/0.071/0.020 ms, ipg/ewma 0.070/0.051 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:52.027" starttime="20181224 22:34:52.026"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:52.028" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:52.028" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:52.028" starttime="20181224 22:34:52.027"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:52.028" starttime="20181224 22:34:52.028"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:52.029" starttime="20181224 22:34:51.521"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:52.029" starttime="20181224 22:34:51.520"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:52.029" starttime="20181224 22:34:51.519"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:52.029" starttime="20181224 22:34:45.369"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:52.029" starttime="20181224 22:34:45.369"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:52.029" starttime="20181224 22:34:45.368"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:52.029" starttime="20181224 22:34:45.365"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-Leaf2">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:52.030" starttime="20181224 22:34:52.029"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:34:52.030" level="INFO">${switch_info} = {'username': 'admin', 'index': 5, 'node': Node(connection=EapiConnection(transport=https://10.255.255.202:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf2', 'host': '10.255.255.202', 'tran...</msg>
<status status="PASS" endtime="20181224 22:34:52.030" starttime="20181224 22:34:52.030"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:34:52.031" level="INFO">{'username': 'admin', 'index': 5, 'node': Node(connection=EapiConnection(transport=https://10.255.255.202:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf2', 'host': '10.255.255.202', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.202:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:34:52.031" starttime="20181224 22:34:52.030"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:52.031" level="INFO">DCA-Leaf2</msg>
<status status="PASS" endtime="20181224 22:34:52.031" starttime="20181224 22:34:52.031"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:52.032" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.202', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.201'], 'loopback': '1.1.1.202'}</msg>
<status status="PASS" endtime="20181224 22:34:52.032" starttime="20181224 22:34:52.032"></status>
</kw>
<kw name="Initiate All Leaf Ping Tests" library="Ping_All">
<doc>Running all Ping Tests on Leafs</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<kw name="Ping Leaf Loopbacks" library="Ping_Loopbacks">
<kw type="for" name="${loopback} IN [ @{loopback_ping} ]">
<kw type="foritem" name="${loopback} = 1.1.1.101">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:52.033" level="INFO">1.1.1.101</msg>
<status status="PASS" endtime="20181224 22:34:52.033" starttime="20181224 22:34:52.033"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:52.945" level="INFO">${output} = [{'command': 'ping 1.1.1.101', 'result': {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=140 ms\n80 bytes from 1.1.1.101: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:52.945" starttime="20181224 22:34:52.034"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:52.946" level="INFO">${result} = {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=140 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=64 time=155 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:52.946" starttime="20181224 22:34:52.945"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:52.946" level="INFO">{u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=140 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=64 time=155 ms\n80 bytes from 1.1.1.101: icmp_seq=3 ttl=64 time=174 ms\n80 bytes from 1.1.1.101: icmp_seq=4 ttl=64 time=192 ms\n80 bytes from 1.1.1.101: icmp_seq=5 ttl=64 time=209 ms\n\n--- 1.1.1.101 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 140.454/174.532/209.828/24.764 ms, pipe 5, ipg/ewma 11.691/159.315 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:52.946" starttime="20181224 22:34:52.946"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:52.947" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:52.947" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:52.947" starttime="20181224 22:34:52.947"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:52.948" starttime="20181224 22:34:52.948"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:52.948" starttime="20181224 22:34:52.034"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:52.948" starttime="20181224 22:34:52.034"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:52.948" starttime="20181224 22:34:52.033"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.102">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:52.949" level="INFO">1.1.1.102</msg>
<status status="PASS" endtime="20181224 22:34:52.949" starttime="20181224 22:34:52.949"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:53.687" level="INFO">${output} = [{'command': 'ping 1.1.1.102', 'result': {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=141 ms\n80 bytes from 1.1.1.102: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:53.687" starttime="20181224 22:34:52.950"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:53.688" level="INFO">${result} = {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=141 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=64 time=152 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:53.688" starttime="20181224 22:34:53.687"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:53.688" level="INFO">{u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=141 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=64 time=152 ms\n80 bytes from 1.1.1.102: icmp_seq=3 ttl=64 time=171 ms\n80 bytes from 1.1.1.102: icmp_seq=4 ttl=64 time=188 ms\n80 bytes from 1.1.1.102: icmp_seq=5 ttl=64 time=206 ms\n\n--- 1.1.1.102 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 47ms\nrtt min/avg/max/mdev = 141.695/172.145/206.546/23.540 ms, pipe 5, ipg/ewma 11.852/158.678 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:53.689" starttime="20181224 22:34:53.688"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:53.689" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:53.689" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:53.689" starttime="20181224 22:34:53.689"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:53.690" starttime="20181224 22:34:53.690"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:53.690" starttime="20181224 22:34:52.950"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:53.690" starttime="20181224 22:34:52.949"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:53.690" starttime="20181224 22:34:52.949"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.201">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:53.691" level="INFO">1.1.1.201</msg>
<status status="PASS" endtime="20181224 22:34:53.691" starttime="20181224 22:34:53.691"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:54.656" level="INFO">${output} = [{'command': 'ping 1.1.1.201', 'result': {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=229 ms\n80 bytes from 1.1.1.201: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:54.656" starttime="20181224 22:34:53.692"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:54.657" level="INFO">${result} = {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=229 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=64 time=247 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:54.657" starttime="20181224 22:34:54.657"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:54.658" level="INFO">{u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=229 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=64 time=247 ms\n80 bytes from 1.1.1.201: icmp_seq=3 ttl=64 time=269 ms\n80 bytes from 1.1.1.201: icmp_seq=4 ttl=64 time=292 ms\n80 bytes from 1.1.1.201: icmp_seq=5 ttl=64 time=315 ms\n\n--- 1.1.1.201 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 45ms\nrtt min/avg/max/mdev = 229.357/270.830/315.370/30.842 ms, pipe 5, ipg/ewma 11.365/252.379 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:54.658" starttime="20181224 22:34:54.658"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:54.659" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:54.659" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:54.659" starttime="20181224 22:34:54.658"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:54.660" starttime="20181224 22:34:54.659"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:54.660" starttime="20181224 22:34:53.692"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:54.660" starttime="20181224 22:34:53.691"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:54.660" starttime="20181224 22:34:53.690"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.202">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:54.661" level="INFO">1.1.1.202</msg>
<status status="PASS" endtime="20181224 22:34:54.661" starttime="20181224 22:34:54.660"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:55.200" level="INFO">${output} = [{'command': 'ping 1.1.1.202', 'result': {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=0.095 ms\n80 bytes from 1.1.1.202: icmp_seq...</msg>
<status status="PASS" endtime="20181224 22:34:55.200" starttime="20181224 22:34:54.662"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:55.201" level="INFO">${result} = {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=0.095 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=64 time=0.031 ms\n80 bytes from 1....</msg>
<status status="PASS" endtime="20181224 22:34:55.201" starttime="20181224 22:34:55.200"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:55.201" level="INFO">{u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=0.095 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=64 time=0.031 ms\n80 bytes from 1.1.1.202: icmp_seq=3 ttl=64 time=0.023 ms\n80 bytes from 1.1.1.202: icmp_seq=4 ttl=64 time=0.022 ms\n80 bytes from 1.1.1.202: icmp_seq=5 ttl=64 time=0.022 ms\n\n--- 1.1.1.202 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.022/0.038/0.095/0.029 ms, ipg/ewma 0.078/0.065 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:55.202" starttime="20181224 22:34:55.201"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:55.202" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:55.202" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:55.202" starttime="20181224 22:34:55.202"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:55.203" starttime="20181224 22:34:55.203"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:55.203" starttime="20181224 22:34:54.661"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:55.203" starttime="20181224 22:34:54.661"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:55.203" starttime="20181224 22:34:54.660"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.203">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:55.204" level="INFO">1.1.1.203</msg>
<status status="PASS" endtime="20181224 22:34:55.204" starttime="20181224 22:34:55.204"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:56.221" level="INFO">${output} = [{'command': 'ping 1.1.1.203', 'result': {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=63 time=419 ms\n80 bytes from 1.1.1.203: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:56.221" starttime="20181224 22:34:55.205"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:56.222" level="INFO">${result} = {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=63 time=419 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=63 time=431 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:56.222" starttime="20181224 22:34:56.222"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:56.223" level="INFO">{u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=63 time=419 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=63 time=431 ms\n80 bytes from 1.1.1.203: icmp_seq=3 ttl=63 time=448 ms\n80 bytes from 1.1.1.203: icmp_seq=4 ttl=63 time=465 ms\n80 bytes from 1.1.1.203: icmp_seq=5 ttl=63 time=483 ms\n\n--- 1.1.1.203 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 45ms\nrtt min/avg/max/mdev = 419.145/449.545/483.170/23.076 ms, pipe 5, ipg/ewma 11.444/436.063 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:56.223" starttime="20181224 22:34:56.223"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:56.224" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:56.224" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:56.224" starttime="20181224 22:34:56.223"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:56.225" starttime="20181224 22:34:56.224"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:56.225" starttime="20181224 22:34:55.205"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:56.225" starttime="20181224 22:34:55.204"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:56.225" starttime="20181224 22:34:55.203"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.204">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:56.226" level="INFO">1.1.1.204</msg>
<status status="PASS" endtime="20181224 22:34:56.226" starttime="20181224 22:34:56.225"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:57.243" level="INFO">${output} = [{'command': 'ping 1.1.1.204', 'result': {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=63 time=415 ms\n80 bytes from 1.1.1.204: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:57.243" starttime="20181224 22:34:56.227"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:57.244" level="INFO">${result} = {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=63 time=415 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=63 time=426 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:57.244" starttime="20181224 22:34:57.243"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:57.244" level="INFO">{u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=63 time=415 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=63 time=426 ms\n80 bytes from 1.1.1.204: icmp_seq=3 ttl=63 time=444 ms\n80 bytes from 1.1.1.204: icmp_seq=4 ttl=63 time=462 ms\n80 bytes from 1.1.1.204: icmp_seq=5 ttl=63 time=480 ms\n\n--- 1.1.1.204 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 415.224/446.033/480.885/23.790 ms, pipe 5, ipg/ewma 11.543/432.405 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:57.244" starttime="20181224 22:34:57.244"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:57.245" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:57.245" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:57.245" starttime="20181224 22:34:57.245"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:57.246" starttime="20181224 22:34:57.246"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:57.246" starttime="20181224 22:34:56.226"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:57.247" starttime="20181224 22:34:56.226"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:57.247" starttime="20181224 22:34:56.225"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.1">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:57.247" level="INFO">2.2.2.1</msg>
<status status="PASS" endtime="20181224 22:34:57.247" starttime="20181224 22:34:57.247"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:57.729" level="INFO">${output} = [{'command': 'ping 2.2.2.1', 'result': {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=0.071 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 ...</msg>
<status status="PASS" endtime="20181224 22:34:57.729" starttime="20181224 22:34:57.248"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:57.730" level="INFO">${result} = {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=0.071 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 time=0.029 ms\n80 bytes from 2.2.2.1: i...</msg>
<status status="PASS" endtime="20181224 22:34:57.730" starttime="20181224 22:34:57.729"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:57.730" level="INFO">{u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=0.071 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 time=0.029 ms\n80 bytes from 2.2.2.1: icmp_seq=3 ttl=64 time=0.023 ms\n80 bytes from 2.2.2.1: icmp_seq=4 ttl=64 time=0.022 ms\n80 bytes from 2.2.2.1: icmp_seq=5 ttl=64 time=0.022 ms\n\n--- 2.2.2.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.022/0.033/0.071/0.019 ms, ipg/ewma 0.070/0.051 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:57.730" starttime="20181224 22:34:57.730"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:57.731" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:57.731" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:57.731" starttime="20181224 22:34:57.731"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:57.743" starttime="20181224 22:34:57.732"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:57.743" starttime="20181224 22:34:57.248"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:57.743" starttime="20181224 22:34:57.248"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:57.743" starttime="20181224 22:34:57.247"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.2">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:57.744" level="INFO">2.2.2.2</msg>
<status status="PASS" endtime="20181224 22:34:57.744" starttime="20181224 22:34:57.743"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:58.799" level="INFO">${output} = [{'command': 'ping 2.2.2.2', 'result': {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=63 time=400 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=63 ti...</msg>
<status status="PASS" endtime="20181224 22:34:58.799" starttime="20181224 22:34:57.745"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:58.800" level="INFO">${result} = {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=63 time=400 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=63 time=411 ms\n80 bytes from 2.2.2.2: icmp_...</msg>
<status status="PASS" endtime="20181224 22:34:58.800" starttime="20181224 22:34:58.799"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:58.801" level="INFO">{u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=63 time=400 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=63 time=411 ms\n80 bytes from 2.2.2.2: icmp_seq=3 ttl=63 time=429 ms\n80 bytes from 2.2.2.2: icmp_seq=4 ttl=63 time=445 ms\n80 bytes from 2.2.2.2: icmp_seq=5 ttl=63 time=463 ms\n\n--- 2.2.2.2 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 400.318/429.993/463.001/22.646 ms, pipe 5, ipg/ewma 11.561/416.842 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:58.801" starttime="20181224 22:34:58.800"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:58.801" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:58.802" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:58.802" starttime="20181224 22:34:58.801"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:58.802" starttime="20181224 22:34:58.802"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:58.802" starttime="20181224 22:34:57.744"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:58.803" starttime="20181224 22:34:57.744"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:58.803" starttime="20181224 22:34:57.743"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:58.803" starttime="20181224 22:34:52.033"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:58.803" starttime="20181224 22:34:52.033"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:58.803" starttime="20181224 22:34:52.032"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:58.803" starttime="20181224 22:34:52.029"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-Leaf1">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:58.804" starttime="20181224 22:34:58.803"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:34:58.804" level="INFO">${switch_info} = {'username': 'admin', 'index': 6, 'node': Node(connection=EapiConnection(transport=https://10.255.255.201:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf1', 'host': '10.255.255.201', 'tran...</msg>
<status status="PASS" endtime="20181224 22:34:58.804" starttime="20181224 22:34:58.804"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:34:58.805" level="INFO">{'username': 'admin', 'index': 6, 'node': Node(connection=EapiConnection(transport=https://10.255.255.201:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf1', 'host': '10.255.255.201', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.201:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:34:58.805" starttime="20181224 22:34:58.804"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:34:58.805" level="INFO">DCA-Leaf1</msg>
<status status="PASS" endtime="20181224 22:34:58.805" starttime="20181224 22:34:58.805"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:34:58.806" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.201', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.202'], 'loopback': '1.1.1.201'}</msg>
<status status="PASS" endtime="20181224 22:34:58.806" starttime="20181224 22:34:58.805"></status>
</kw>
<kw name="Initiate All Leaf Ping Tests" library="Ping_All">
<doc>Running all Ping Tests on Leafs</doc>
<arguments>
<arg>${target_dictionary}</arg>
</arguments>
<kw name="Ping Leaf Loopbacks" library="Ping_Loopbacks">
<kw type="for" name="${loopback} IN [ @{loopback_ping} ]">
<kw type="foritem" name="${loopback} = 1.1.1.101">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:58.807" level="INFO">1.1.1.101</msg>
<status status="PASS" endtime="20181224 22:34:58.807" starttime="20181224 22:34:58.807"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:34:59.719" level="INFO">${output} = [{'command': 'ping 1.1.1.101', 'result': {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=163 ms\n80 bytes from 1.1.1.101: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:34:59.719" starttime="20181224 22:34:58.808"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:34:59.720" level="INFO">${result} = {u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=163 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=64 time=176 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:34:59.720" starttime="20181224 22:34:59.719"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:34:59.721" level="INFO">{u'messages': [u'PING 1.1.1.101 (1.1.1.101) 72(100) bytes of data.\n80 bytes from 1.1.1.101: icmp_seq=1 ttl=64 time=163 ms\n80 bytes from 1.1.1.101: icmp_seq=2 ttl=64 time=176 ms\n80 bytes from 1.1.1.101: icmp_seq=3 ttl=64 time=193 ms\n80 bytes from 1.1.1.101: icmp_seq=4 ttl=64 time=211 ms\n80 bytes from 1.1.1.101: icmp_seq=5 ttl=64 time=228 ms\n\n--- 1.1.1.101 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 44ms\nrtt min/avg/max/mdev = 163.346/194.510/228.105/23.399 ms, pipe 5, ipg/ewma 11.184/180.665 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:34:59.721" starttime="20181224 22:34:59.720"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:34:59.722" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:34:59.722" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:34:59.722" starttime="20181224 22:34:59.721"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:34:59.722" starttime="20181224 22:34:59.722"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:59.723" starttime="20181224 22:34:58.808"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:59.723" starttime="20181224 22:34:58.808"></status>
</kw>
<status status="PASS" endtime="20181224 22:34:59.723" starttime="20181224 22:34:58.807"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.102">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:34:59.723" level="INFO">1.1.1.102</msg>
<status status="PASS" endtime="20181224 22:34:59.723" starttime="20181224 22:34:59.723"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:35:00.448" level="INFO">${output} = [{'command': 'ping 1.1.1.102', 'result': {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=145 ms\n80 bytes from 1.1.1.102: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:35:00.448" starttime="20181224 22:34:59.725"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:35:00.449" level="INFO">${result} = {u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=145 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=64 time=156 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:35:00.449" starttime="20181224 22:35:00.448"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:35:00.450" level="INFO">{u'messages': [u'PING 1.1.1.102 (1.1.1.102) 72(100) bytes of data.\n80 bytes from 1.1.1.102: icmp_seq=1 ttl=64 time=145 ms\n80 bytes from 1.1.1.102: icmp_seq=2 ttl=64 time=156 ms\n80 bytes from 1.1.1.102: icmp_seq=3 ttl=64 time=173 ms\n80 bytes from 1.1.1.102: icmp_seq=4 ttl=64 time=190 ms\n80 bytes from 1.1.1.102: icmp_seq=5 ttl=64 time=207 ms\n\n--- 1.1.1.102 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 47ms\nrtt min/avg/max/mdev = 145.108/174.720/207.981/22.563 ms, pipe 5, ipg/ewma 11.906/161.596 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:35:00.450" starttime="20181224 22:35:00.449"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:35:00.451" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:35:00.451" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:35:00.451" starttime="20181224 22:35:00.450"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:00.451" starttime="20181224 22:35:00.451"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:00.451" starttime="20181224 22:34:59.724"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:00.452" starttime="20181224 22:34:59.724"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:00.452" starttime="20181224 22:34:59.723"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.201">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:35:00.452" level="INFO">1.1.1.201</msg>
<status status="PASS" endtime="20181224 22:35:00.453" starttime="20181224 22:35:00.452"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:35:01.025" level="INFO">${output} = [{'command': 'ping 1.1.1.201', 'result': {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=0.086 ms\n80 bytes from 1.1.1.201: icmp_seq...</msg>
<status status="PASS" endtime="20181224 22:35:01.025" starttime="20181224 22:35:00.454"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:35:01.026" level="INFO">${result} = {u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=0.086 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=64 time=0.029 ms\n80 bytes from 1....</msg>
<status status="PASS" endtime="20181224 22:35:01.026" starttime="20181224 22:35:01.025"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:35:01.026" level="INFO">{u'messages': [u'PING 1.1.1.201 (1.1.1.201) 72(100) bytes of data.\n80 bytes from 1.1.1.201: icmp_seq=1 ttl=64 time=0.086 ms\n80 bytes from 1.1.1.201: icmp_seq=2 ttl=64 time=0.029 ms\n80 bytes from 1.1.1.201: icmp_seq=3 ttl=64 time=0.024 ms\n80 bytes from 1.1.1.201: icmp_seq=4 ttl=64 time=0.023 ms\n80 bytes from 1.1.1.201: icmp_seq=5 ttl=64 time=0.022 ms\n\n--- 1.1.1.201 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.022/0.036/0.086/0.025 ms, ipg/ewma 0.076/0.060 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:35:01.027" starttime="20181224 22:35:01.026"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:35:01.027" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:35:01.028" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:35:01.028" starttime="20181224 22:35:01.027"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:01.028" starttime="20181224 22:35:01.028"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:01.028" starttime="20181224 22:35:00.453"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:01.028" starttime="20181224 22:35:00.453"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:01.029" starttime="20181224 22:35:00.452"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.202">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:35:01.029" level="INFO">1.1.1.202</msg>
<status status="PASS" endtime="20181224 22:35:01.029" starttime="20181224 22:35:01.029"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:35:01.871" level="INFO">${output} = [{'command': 'ping 1.1.1.202', 'result': {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=224 ms\n80 bytes from 1.1.1.202: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:35:01.871" starttime="20181224 22:35:01.030"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:35:01.872" level="INFO">${result} = {u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=224 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=64 time=243 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:35:01.872" starttime="20181224 22:35:01.871"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:35:01.873" level="INFO">{u'messages': [u'PING 1.1.1.202 (1.1.1.202) 72(100) bytes of data.\n80 bytes from 1.1.1.202: icmp_seq=1 ttl=64 time=224 ms\n80 bytes from 1.1.1.202: icmp_seq=2 ttl=64 time=243 ms\n80 bytes from 1.1.1.202: icmp_seq=3 ttl=64 time=267 ms\n80 bytes from 1.1.1.202: icmp_seq=4 ttl=64 time=290 ms\n80 bytes from 1.1.1.202: icmp_seq=5 ttl=64 time=314 ms\n\n--- 1.1.1.202 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 45ms\nrtt min/avg/max/mdev = 224.856/268.212/314.060/31.857 ms, pipe 5, ipg/ewma 11.410/248.886 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:35:01.873" starttime="20181224 22:35:01.872"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:35:01.874" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:35:01.874" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:35:01.874" starttime="20181224 22:35:01.873"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:01.874" starttime="20181224 22:35:01.874"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:01.875" starttime="20181224 22:35:01.030"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:01.875" starttime="20181224 22:35:01.029"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:01.875" starttime="20181224 22:35:01.029"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.203">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:35:01.875" level="INFO">1.1.1.203</msg>
<status status="PASS" endtime="20181224 22:35:01.875" starttime="20181224 22:35:01.875"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:35:02.931" level="INFO">${output} = [{'command': 'ping 1.1.1.203', 'result': {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=63 time=414 ms\n80 bytes from 1.1.1.203: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:35:02.931" starttime="20181224 22:35:01.877"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:35:02.932" level="INFO">${result} = {u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=63 time=414 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=63 time=425 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:35:02.932" starttime="20181224 22:35:02.932"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:35:02.933" level="INFO">{u'messages': [u'PING 1.1.1.203 (1.1.1.203) 72(100) bytes of data.\n80 bytes from 1.1.1.203: icmp_seq=1 ttl=63 time=414 ms\n80 bytes from 1.1.1.203: icmp_seq=2 ttl=63 time=425 ms\n80 bytes from 1.1.1.203: icmp_seq=3 ttl=63 time=442 ms\n80 bytes from 1.1.1.203: icmp_seq=4 ttl=63 time=460 ms\n80 bytes from 1.1.1.203: icmp_seq=5 ttl=63 time=481 ms\n\n--- 1.1.1.203 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 414.267/444.754/481.030/23.949 ms, pipe 5, ipg/ewma 11.589/431.308 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:35:02.933" starttime="20181224 22:35:02.933"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:35:02.934" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:35:02.934" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:35:02.934" starttime="20181224 22:35:02.933"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:02.935" starttime="20181224 22:35:02.934"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:02.935" starttime="20181224 22:35:01.876"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:02.935" starttime="20181224 22:35:01.876"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:02.935" starttime="20181224 22:35:01.875"></status>
</kw>
<kw type="foritem" name="${loopback} = 1.1.1.204">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:35:02.936" level="INFO">1.1.1.204</msg>
<status status="PASS" endtime="20181224 22:35:02.936" starttime="20181224 22:35:02.935"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:35:04.024" level="INFO">${output} = [{'command': 'ping 1.1.1.204', 'result': {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=63 time=454 ms\n80 bytes from 1.1.1.204: icmp_seq=2...</msg>
<status status="PASS" endtime="20181224 22:35:04.024" starttime="20181224 22:35:02.937"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:35:04.025" level="INFO">${result} = {u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=63 time=454 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=63 time=469 ms\n80 bytes from 1.1.1....</msg>
<status status="PASS" endtime="20181224 22:35:04.025" starttime="20181224 22:35:04.024"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:35:04.026" level="INFO">{u'messages': [u'PING 1.1.1.204 (1.1.1.204) 72(100) bytes of data.\n80 bytes from 1.1.1.204: icmp_seq=1 ttl=63 time=454 ms\n80 bytes from 1.1.1.204: icmp_seq=2 ttl=63 time=469 ms\n80 bytes from 1.1.1.204: icmp_seq=3 ttl=63 time=486 ms\n80 bytes from 1.1.1.204: icmp_seq=4 ttl=63 time=504 ms\n80 bytes from 1.1.1.204: icmp_seq=5 ttl=63 time=520 ms\n\n--- 1.1.1.204 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 46ms\nrtt min/avg/max/mdev = 454.948/487.325/520.842/23.545 ms, pipe 5, ipg/ewma 11.651/472.869 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:35:04.026" starttime="20181224 22:35:04.025"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:35:04.027" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:35:04.027" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:35:04.027" starttime="20181224 22:35:04.026"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:04.027" starttime="20181224 22:35:04.027"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:04.028" starttime="20181224 22:35:02.936"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:04.028" starttime="20181224 22:35:02.936"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:04.028" starttime="20181224 22:35:02.935"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.1">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:35:04.028" level="INFO">2.2.2.1</msg>
<status status="PASS" endtime="20181224 22:35:04.029" starttime="20181224 22:35:04.028"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:35:04.518" level="INFO">${output} = [{'command': 'ping 2.2.2.1', 'result': {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=0.067 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 ...</msg>
<status status="PASS" endtime="20181224 22:35:04.518" starttime="20181224 22:35:04.030"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:35:04.519" level="INFO">${result} = {u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=0.067 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 time=0.030 ms\n80 bytes from 2.2.2.1: i...</msg>
<status status="PASS" endtime="20181224 22:35:04.520" starttime="20181224 22:35:04.519"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:35:04.520" level="INFO">{u'messages': [u'PING 2.2.2.1 (2.2.2.1) 72(100) bytes of data.\n80 bytes from 2.2.2.1: icmp_seq=1 ttl=64 time=0.067 ms\n80 bytes from 2.2.2.1: icmp_seq=2 ttl=64 time=0.030 ms\n80 bytes from 2.2.2.1: icmp_seq=3 ttl=64 time=0.024 ms\n80 bytes from 2.2.2.1: icmp_seq=4 ttl=64 time=0.023 ms\n80 bytes from 2.2.2.1: icmp_seq=5 ttl=64 time=0.022 ms\n\n--- 2.2.2.1 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.022/0.033/0.067/0.017 ms, ipg/ewma 0.070/0.049 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:35:04.520" starttime="20181224 22:35:04.520"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:35:04.521" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:35:04.521" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:35:04.521" starttime="20181224 22:35:04.521"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:04.522" starttime="20181224 22:35:04.522"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:04.522" starttime="20181224 22:35:04.029"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:04.522" starttime="20181224 22:35:04.029"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:04.522" starttime="20181224 22:35:04.028"></status>
</kw>
<kw type="foritem" name="${loopback} = 2.2.2.2">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${loopback}</arg>
</arguments>
<msg timestamp="20181224 22:35:04.523" level="INFO">2.2.2.2</msg>
<status status="PASS" endtime="20181224 22:35:04.523" starttime="20181224 22:35:04.523"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate Ping</arg>
<arg>${loopback}</arg>
</arguments>
<kw name="Initiate Ping" library="Initiate_Ping">
<arguments>
<arg>${loopback}</arg>
</arguments>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>ping ${ip}</arg>
</arguments>
<assign>
<var>${output}</var>
</assign>
<msg timestamp="20181224 22:35:05.832" level="INFO">${output} = [{'command': 'ping 2.2.2.2', 'result': {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=63 time=656 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=63 ti...</msg>
<status status="PASS" endtime="20181224 22:35:05.832" starttime="20181224 22:35:04.524"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${output[0]}</arg>
<arg>result</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<msg timestamp="20181224 22:35:05.833" level="INFO">${result} = {u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=63 time=656 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=63 time=673 ms\n80 bytes from 2.2.2.2: icmp_...</msg>
<status status="PASS" endtime="20181224 22:35:05.833" starttime="20181224 22:35:05.833"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result}</arg>
</arguments>
<msg timestamp="20181224 22:35:05.834" level="INFO">{u'messages': [u'PING 2.2.2.2 (2.2.2.2) 72(100) bytes of data.\n80 bytes from 2.2.2.2: icmp_seq=1 ttl=63 time=656 ms\n80 bytes from 2.2.2.2: icmp_seq=2 ttl=63 time=673 ms\n80 bytes from 2.2.2.2: icmp_seq=3 ttl=63 time=694 ms\n80 bytes from 2.2.2.2: icmp_seq=4 ttl=63 time=711 ms\n80 bytes from 2.2.2.2: icmp_seq=5 ttl=63 time=727 ms\n\n--- 2.2.2.2 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 40ms\nrtt min/avg/max/mdev = 656.099/692.554/727.617/25.604 ms, pipe 5, ipg/ewma 10.147/676.185 ms\n']}</msg>
<status status="PASS" endtime="20181224 22:35:05.834" starttime="20181224 22:35:05.834"></status>
</kw>
<kw name="Should Match Regexp" library="BuiltIn">
<doc>Fails if ``string`` does not match ``pattern`` as a regular expression.</doc>
<arguments>
<arg>${result['messages'][0]}</arg>
<arg>(\\d+)% packet loss</arg>
</arguments>
<assign>
<var>${match}</var>
<var>${group1}</var>
</assign>
<msg timestamp="20181224 22:35:05.835" level="INFO">${match} = 0% packet loss</msg>
<msg timestamp="20181224 22:35:05.835" level="INFO">${group1} = 0</msg>
<status status="PASS" endtime="20181224 22:35:05.835" starttime="20181224 22:35:05.834"></status>
</kw>
<kw name="Should Be Equal As Integers" library="BuiltIn">
<doc>Fails if objects are unequal after converting them to integers.</doc>
<arguments>
<arg>${group1}</arg>
<arg>0</arg>
<arg>msg="Packets lost percent not zero!!!"</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:05.836" starttime="20181224 22:35:05.836"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:05.836" starttime="20181224 22:35:04.524"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:05.836" starttime="20181224 22:35:04.523"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:05.836" starttime="20181224 22:35:04.522"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:05.837" starttime="20181224 22:34:58.807"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:05.837" starttime="20181224 22:34:58.806"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:05.837" starttime="20181224 22:34:58.806"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:05.837" starttime="20181224 22:34:58.803"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:05.837" starttime="20181224 22:34:39.001"></status>
</kw>
<doc>Validate Leafs are able to ping loopbacks</doc>
<tags>
<tag>LEAF_PING</tag>
</tags>
<status status="PASS" endtime="20181224 22:35:05.837" critical="yes" starttime="20181224 22:34:39.001"></status>
</test>
<test id="s1-t5" name="Leaf OSPF Neighbor Validation">
<kw type="for" name="${leaf} IN [ @{leafs} ]">
<kw type="foritem" name="${leaf} = DCA-BL2">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:05.838" starttime="20181224 22:35:05.838"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:35:05.839" level="INFO">${switch_info} = {'username': 'admin', 'index': 3, 'node': Node(connection=EapiConnection(transport=https://10.255.255.204:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL2', 'host': '10.255.255.204', 'transp...</msg>
<status status="PASS" endtime="20181224 22:35:05.839" starttime="20181224 22:35:05.839"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:35:05.839" level="INFO">{'username': 'admin', 'index': 3, 'node': Node(connection=EapiConnection(transport=https://10.255.255.204:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL2', 'host': '10.255.255.204', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.204:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:35:05.839" starttime="20181224 22:35:05.839"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:35:05.840" level="INFO">DCA-BL2</msg>
<status status="PASS" endtime="20181224 22:35:05.840" starttime="20181224 22:35:05.840"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:35:05.840" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.204', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.203'], 'loopback': '1.1.1.204'}</msg>
<status status="PASS" endtime="20181224 22:35:05.840" starttime="20181224 22:35:05.840"></status>
</kw>
<kw name="Validate OSPF Neighbors" library="Validate_OSPF_Neighbors">
<doc>Validating OSPF Neighbors on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${leaf}</arg>
</arguments>
<kw name="Get Neighbors" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_neighbors}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show ip ospf neighbor</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:35:05.842" level="INFO">${cmd} = show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:35:05.842" starttime="20181224 22:35:05.841"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:35:05.842" level="INFO">show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:35:05.842" starttime="20181224 22:35:05.842"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:06.459" starttime="20181224 22:35:05.843"></status>
</kw>
<msg timestamp="20181224 22:35:06.459" level="INFO">${result} = [{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712201.013455, u'priority': 0, u'interfaceName': u'Ethernet2',...</msg>
<status status="PASS" endtime="20181224 22:35:06.459" starttime="20181224 22:35:05.842"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.460" level="INFO">{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712201.013455, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 2, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629732.013698}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.204.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712208.015129, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629737.015326}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.204.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712204.017356, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545710615.017555}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.254', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]}}}}}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:35:06.460" starttime="20181224 22:35:06.460"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']['vrfs']['default']['instList']['1']}</arg>
<arg>ospfNeighborEntries</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:35:06.461" level="INFO">${result_dict} = [{u'inactivity': 1545712201.013455, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:35:06.461" starttime="20181224 22:35:06.461"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.462" level="INFO">[{u'inactivity': 1545712201.013455, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 2, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629732.013698}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.204.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712208.015129, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629737.015326}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.204.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712204.017356, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545710615.017555}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.254', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:35:06.462" starttime="20181224 22:35:06.462"></status>
</kw>
<msg timestamp="20181224 22:35:06.462" level="INFO">${current_neighbors} = [{u'inactivity': 1545712201.013455, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:35:06.462" starttime="20181224 22:35:05.841"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.463" level="INFO">[{u'inactivity': 1545712201.013455, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 2, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629732.013698}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.204.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712208.015129, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629737.015326}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.204.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712204.017356, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545710615.017555}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.254', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:35:06.463" starttime="20181224 22:35:06.463"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>ospf_neighbors</arg>
</arguments>
<assign>
<var>@{target_neighbors}</var>
</assign>
<msg timestamp="20181224 22:35:06.464" level="INFO">@{target_neighbors} = [ 1.1.1.101 | 1.1.1.102 | 1.1.1.203 ]</msg>
<status status="PASS" endtime="20181224 22:35:06.464" starttime="20181224 22:35:06.463"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate OSPF Validation</arg>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Initiate OSPF Validation" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_neighbors}</var>
</assign>
<msg timestamp="20181224 22:35:06.465" level="INFO">@{established_neighbors} = [ ]</msg>
<status status="PASS" endtime="20181224 22:35:06.465" starttime="20181224 22:35:06.465"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.466" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:35:06.466" starttime="20181224 22:35:06.465"></status>
</kw>
<kw type="for" name="${cNeighbor} IN [ @{current_neighbors} ]">
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712201.013455, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.466" level="INFO">{u'inactivity': 1545712201.013455, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 2, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629732.013698}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.204.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:06.466" starttime="20181224 22:35:06.466"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:06.469" level="INFO">1.1.1.102 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:06.469" starttime="20181224 22:35:06.468"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.469" starttime="20181224 22:35:06.468"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.469" starttime="20181224 22:35:06.467"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.469" starttime="20181224 22:35:06.467"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:06.470" starttime="20181224 22:35:06.470"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.470" starttime="20181224 22:35:06.469"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.470" starttime="20181224 22:35:06.469"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:06.471" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:35:06.471" level="INFO">${established_neighbors_length} = 1</msg>
<status status="PASS" endtime="20181224 22:35:06.471" starttime="20181224 22:35:06.471"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.472" level="INFO">[u'1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:06.472" starttime="20181224 22:35:06.471"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.472" starttime="20181224 22:35:06.471"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:06.473" starttime="20181224 22:35:06.472"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.473" starttime="20181224 22:35:06.472"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.473" starttime="20181224 22:35:06.466"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712208.015129, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.473" level="INFO">{u'inactivity': 1545712208.015129, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629737.015326}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.204.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:06.473" starttime="20181224 22:35:06.473"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:06.475" level="INFO">1.1.1.101 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:06.475" starttime="20181224 22:35:06.475"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.475" starttime="20181224 22:35:06.474"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.475" starttime="20181224 22:35:06.474"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.475" starttime="20181224 22:35:06.473"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:06.477" starttime="20181224 22:35:06.476"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.477" starttime="20181224 22:35:06.476"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.477" starttime="20181224 22:35:06.475"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:06.477" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:35:06.477" level="INFO">${established_neighbors_length} = 2</msg>
<status status="PASS" endtime="20181224 22:35:06.477" starttime="20181224 22:35:06.477"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.478" level="INFO">[u'1.1.1.102', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:06.478" starttime="20181224 22:35:06.478"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.478" starttime="20181224 22:35:06.477"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:06.479" starttime="20181224 22:35:06.479"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.479" starttime="20181224 22:35:06.478"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.479" starttime="20181224 22:35:06.473"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712204.017356, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'bac...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.480" level="INFO">{u'inactivity': 1545712204.017356, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.203', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545710615.017555}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.254', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:06.480" starttime="20181224 22:35:06.479"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:06.481" level="INFO">1.1.1.203 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:06.481" starttime="20181224 22:35:06.481"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.481" starttime="20181224 22:35:06.481"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.481" starttime="20181224 22:35:06.480"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.482" starttime="20181224 22:35:06.480"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:06.483" starttime="20181224 22:35:06.483"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.483" starttime="20181224 22:35:06.482"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.483" starttime="20181224 22:35:06.482"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:06.483" level="INFO">Length is 3</msg>
<msg timestamp="20181224 22:35:06.483" level="INFO">${established_neighbors_length} = 3</msg>
<status status="PASS" endtime="20181224 22:35:06.484" starttime="20181224 22:35:06.483"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.484" level="INFO">[u'1.1.1.102', u'1.1.1.101', u'1.1.1.203']</msg>
<status status="PASS" endtime="20181224 22:35:06.484" starttime="20181224 22:35:06.484"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.485" starttime="20181224 22:35:06.484"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:06.485" starttime="20181224 22:35:06.485"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.485" starttime="20181224 22:35:06.485"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.485" starttime="20181224 22:35:06.479"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.485" starttime="20181224 22:35:06.466"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.486" level="INFO">[u'1.1.1.102', u'1.1.1.101', u'1.1.1.203']</msg>
<status status="PASS" endtime="20181224 22:35:06.486" starttime="20181224 22:35:06.486"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.486" level="INFO">['1.1.1.101', '1.1.1.102', '1.1.1.203']</msg>
<status status="PASS" endtime="20181224 22:35:06.486" starttime="20181224 22:35:06.486"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_neighbors} ]">
<kw type="foritem" name="${listObject} = 1.1.1.101">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:06.487" starttime="20181224 22:35:06.487"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.487" starttime="20181224 22:35:06.487"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.487" starttime="20181224 22:35:06.486"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.102">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:06.488" starttime="20181224 22:35:06.488"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.488" starttime="20181224 22:35:06.488"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.488" starttime="20181224 22:35:06.487"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.203">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:06.489" starttime="20181224 22:35:06.489"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.489" starttime="20181224 22:35:06.488"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.489" starttime="20181224 22:35:06.488"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.489" starttime="20181224 22:35:06.486"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.489" starttime="20181224 22:35:06.464"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.489" starttime="20181224 22:35:06.464"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.489" starttime="20181224 22:35:05.841"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:06.489" starttime="20181224 22:35:05.838"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-BL1">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:06.490" starttime="20181224 22:35:06.490"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:35:06.490" level="INFO">${switch_info} = {'username': 'admin', 'index': 4, 'node': Node(connection=EapiConnection(transport=https://10.255.255.203:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL1', 'host': '10.255.255.203', 'transp...</msg>
<status status="PASS" endtime="20181224 22:35:06.490" starttime="20181224 22:35:06.490"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.491" level="INFO">{'username': 'admin', 'index': 4, 'node': Node(connection=EapiConnection(transport=https://10.255.255.203:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL1', 'host': '10.255.255.203', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.203:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:35:06.491" starttime="20181224 22:35:06.490"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.491" level="INFO">DCA-BL1</msg>
<status status="PASS" endtime="20181224 22:35:06.491" starttime="20181224 22:35:06.491"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:35:06.491" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.203', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.204'], 'loopback': '1.1.1.203'}</msg>
<status status="PASS" endtime="20181224 22:35:06.491" starttime="20181224 22:35:06.491"></status>
</kw>
<kw name="Validate OSPF Neighbors" library="Validate_OSPF_Neighbors">
<doc>Validating OSPF Neighbors on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${leaf}</arg>
</arguments>
<kw name="Get Neighbors" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_neighbors}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show ip ospf neighbor</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:35:06.492" level="INFO">${cmd} = show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:35:06.492" starttime="20181224 22:35:06.492"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:35:06.493" level="INFO">show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:35:06.493" starttime="20181224 22:35:06.493"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.079" starttime="20181224 22:35:06.493"></status>
</kw>
<msg timestamp="20181224 22:35:07.079" level="INFO">${result} = [{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712201.092685, u'priority': 0, u'interfaceName': u'Ethernet2',...</msg>
<status status="PASS" endtime="20181224 22:35:07.079" starttime="20181224 22:35:06.493"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.080" level="INFO">{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712201.092685, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 6, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629733.092924}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.203.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712203.094402, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 1, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629724.094608}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.203.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712202.096909, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545710614.097108}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.255', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]}}}}}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:35:07.081" starttime="20181224 22:35:07.080"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']['vrfs']['default']['instList']['1']}</arg>
<arg>ospfNeighborEntries</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:35:07.081" level="INFO">${result_dict} = [{u'inactivity': 1545712201.092685, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:35:07.082" starttime="20181224 22:35:07.081"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.082" level="INFO">[{u'inactivity': 1545712201.092685, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 6, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629733.092924}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.203.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712203.094402, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 1, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629724.094608}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.203.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712202.096909, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545710614.097108}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.255', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:35:07.082" starttime="20181224 22:35:07.082"></status>
</kw>
<msg timestamp="20181224 22:35:07.083" level="INFO">${current_neighbors} = [{u'inactivity': 1545712201.092685, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:35:07.083" starttime="20181224 22:35:06.492"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.083" level="INFO">[{u'inactivity': 1545712201.092685, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 6, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629733.092924}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.203.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712203.094402, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 1, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629724.094608}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.203.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712202.096909, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545710614.097108}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.255', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:35:07.083" starttime="20181224 22:35:07.083"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>ospf_neighbors</arg>
</arguments>
<assign>
<var>@{target_neighbors}</var>
</assign>
<msg timestamp="20181224 22:35:07.084" level="INFO">@{target_neighbors} = [ 1.1.1.101 | 1.1.1.102 | 1.1.1.204 ]</msg>
<status status="PASS" endtime="20181224 22:35:07.084" starttime="20181224 22:35:07.084"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate OSPF Validation</arg>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Initiate OSPF Validation" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_neighbors}</var>
</assign>
<msg timestamp="20181224 22:35:07.085" level="INFO">@{established_neighbors} = [ ]</msg>
<status status="PASS" endtime="20181224 22:35:07.085" starttime="20181224 22:35:07.085"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.086" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:35:07.086" starttime="20181224 22:35:07.086"></status>
</kw>
<kw type="for" name="${cNeighbor} IN [ @{current_neighbors} ]">
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712201.092685, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.087" level="INFO">{u'inactivity': 1545712201.092685, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 6, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629733.092924}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.203.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:07.087" starttime="20181224 22:35:07.086"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:07.089" level="INFO">1.1.1.102 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:07.089" starttime="20181224 22:35:07.089"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.089" starttime="20181224 22:35:07.088"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.089" starttime="20181224 22:35:07.087"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.089" starttime="20181224 22:35:07.087"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.091" starttime="20181224 22:35:07.090"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.091" starttime="20181224 22:35:07.090"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.091" starttime="20181224 22:35:07.089"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:07.091" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:35:07.091" level="INFO">${established_neighbors_length} = 1</msg>
<status status="PASS" endtime="20181224 22:35:07.091" starttime="20181224 22:35:07.091"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.092" level="INFO">[u'1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:07.092" starttime="20181224 22:35:07.092"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.092" starttime="20181224 22:35:07.091"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.093" starttime="20181224 22:35:07.093"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.093" starttime="20181224 22:35:07.092"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.093" starttime="20181224 22:35:07.086"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712203.094402, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.093" level="INFO">{u'inactivity': 1545712203.094402, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 1, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629724.094608}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.203.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:07.094" starttime="20181224 22:35:07.093"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:07.095" level="INFO">1.1.1.101 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:07.095" starttime="20181224 22:35:07.095"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.095" starttime="20181224 22:35:07.095"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.095" starttime="20181224 22:35:07.094"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.095" starttime="20181224 22:35:07.094"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.097" starttime="20181224 22:35:07.097"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.097" starttime="20181224 22:35:07.096"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.097" starttime="20181224 22:35:07.096"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:07.097" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:35:07.097" level="INFO">${established_neighbors_length} = 2</msg>
<status status="PASS" endtime="20181224 22:35:07.097" starttime="20181224 22:35:07.097"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.098" level="INFO">[u'1.1.1.102', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:07.098" starttime="20181224 22:35:07.098"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.098" starttime="20181224 22:35:07.098"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.099" starttime="20181224 22:35:07.099"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.099" starttime="20181224 22:35:07.098"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.099" starttime="20181224 22:35:07.093"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712202.096909, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'bac...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.100" level="INFO">{u'inactivity': 1545712202.096909, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.204', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545710614.097108}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.255', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:07.100" starttime="20181224 22:35:07.099"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:07.101" level="INFO">1.1.1.204 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:07.101" starttime="20181224 22:35:07.101"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.101" starttime="20181224 22:35:07.101"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.101" starttime="20181224 22:35:07.100"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.101" starttime="20181224 22:35:07.100"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.103" starttime="20181224 22:35:07.102"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.103" starttime="20181224 22:35:07.102"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.103" starttime="20181224 22:35:07.102"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:07.103" level="INFO">Length is 3</msg>
<msg timestamp="20181224 22:35:07.103" level="INFO">${established_neighbors_length} = 3</msg>
<status status="PASS" endtime="20181224 22:35:07.103" starttime="20181224 22:35:07.103"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.104" level="INFO">[u'1.1.1.102', u'1.1.1.101', u'1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:35:07.104" starttime="20181224 22:35:07.104"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.104" starttime="20181224 22:35:07.104"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.105" starttime="20181224 22:35:07.105"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.105" starttime="20181224 22:35:07.104"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.105" starttime="20181224 22:35:07.099"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.105" starttime="20181224 22:35:07.086"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.105" level="INFO">[u'1.1.1.102', u'1.1.1.101', u'1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:35:07.105" starttime="20181224 22:35:07.105"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.106" level="INFO">['1.1.1.101', '1.1.1.102', '1.1.1.204']</msg>
<status status="PASS" endtime="20181224 22:35:07.106" starttime="20181224 22:35:07.106"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_neighbors} ]">
<kw type="foritem" name="${listObject} = 1.1.1.101">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.107" starttime="20181224 22:35:07.107"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.107" starttime="20181224 22:35:07.106"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.107" starttime="20181224 22:35:07.106"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.102">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.108" starttime="20181224 22:35:07.107"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.108" starttime="20181224 22:35:07.107"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.108" starttime="20181224 22:35:07.107"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.204">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.109" starttime="20181224 22:35:07.108"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.109" starttime="20181224 22:35:07.108"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.109" starttime="20181224 22:35:07.108"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.109" starttime="20181224 22:35:07.106"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.109" starttime="20181224 22:35:07.085"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.109" starttime="20181224 22:35:07.084"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.109" starttime="20181224 22:35:06.492"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.109" starttime="20181224 22:35:06.489"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-Leaf2">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.109" starttime="20181224 22:35:07.109"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:35:07.110" level="INFO">${switch_info} = {'username': 'admin', 'index': 5, 'node': Node(connection=EapiConnection(transport=https://10.255.255.202:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf2', 'host': '10.255.255.202', 'tran...</msg>
<status status="PASS" endtime="20181224 22:35:07.110" starttime="20181224 22:35:07.110"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.110" level="INFO">{'username': 'admin', 'index': 5, 'node': Node(connection=EapiConnection(transport=https://10.255.255.202:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf2', 'host': '10.255.255.202', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.202:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:35:07.110" starttime="20181224 22:35:07.110"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.110" level="INFO">DCA-Leaf2</msg>
<status status="PASS" endtime="20181224 22:35:07.111" starttime="20181224 22:35:07.110"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:35:07.111" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.202', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.201'], 'loopback': '1.1.1.202'}</msg>
<status status="PASS" endtime="20181224 22:35:07.111" starttime="20181224 22:35:07.111"></status>
</kw>
<kw name="Validate OSPF Neighbors" library="Validate_OSPF_Neighbors">
<doc>Validating OSPF Neighbors on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${leaf}</arg>
</arguments>
<kw name="Get Neighbors" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_neighbors}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show ip ospf neighbor</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:35:07.112" level="INFO">${cmd} = show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:35:07.112" starttime="20181224 22:35:07.112"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.112" level="INFO">show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:35:07.112" starttime="20181224 22:35:07.112"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.698" starttime="20181224 22:35:07.113"></status>
</kw>
<msg timestamp="20181224 22:35:07.699" level="INFO">${result} = [{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712201.284385, u'priority': 0, u'interfaceName': u'Ethernet1',...</msg>
<status status="PASS" endtime="20181224 22:35:07.699" starttime="20181224 22:35:07.113"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.699" level="INFO">{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712201.284385, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 26, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629735.284663}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.202.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712202.286125, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 31, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629733.28634}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.202.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712209.288396, u'priority': 1, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545709872.288602}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.254', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]}}}}}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:35:07.700" starttime="20181224 22:35:07.699"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']['vrfs']['default']['instList']['1']}</arg>
<arg>ospfNeighborEntries</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:35:07.701" level="INFO">${result_dict} = [{u'inactivity': 1545712201.284385, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:35:07.701" starttime="20181224 22:35:07.700"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.701" level="INFO">[{u'inactivity': 1545712201.284385, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 26, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629735.284663}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.202.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712202.286125, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 31, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629733.28634}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.202.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712209.288396, u'priority': 1, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545709872.288602}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.254', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:35:07.701" starttime="20181224 22:35:07.701"></status>
</kw>
<msg timestamp="20181224 22:35:07.702" level="INFO">${current_neighbors} = [{u'inactivity': 1545712201.284385, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:35:07.702" starttime="20181224 22:35:07.111"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.702" level="INFO">[{u'inactivity': 1545712201.284385, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 26, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629735.284663}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.202.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712202.286125, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 31, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629733.28634}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.202.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712209.288396, u'priority': 1, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545709872.288602}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.254', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:35:07.702" starttime="20181224 22:35:07.702"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>ospf_neighbors</arg>
</arguments>
<assign>
<var>@{target_neighbors}</var>
</assign>
<msg timestamp="20181224 22:35:07.703" level="INFO">@{target_neighbors} = [ 1.1.1.101 | 1.1.1.102 | 1.1.1.201 ]</msg>
<status status="PASS" endtime="20181224 22:35:07.703" starttime="20181224 22:35:07.702"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate OSPF Validation</arg>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Initiate OSPF Validation" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_neighbors}</var>
</assign>
<msg timestamp="20181224 22:35:07.704" level="INFO">@{established_neighbors} = [ ]</msg>
<status status="PASS" endtime="20181224 22:35:07.704" starttime="20181224 22:35:07.704"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.705" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:35:07.705" starttime="20181224 22:35:07.704"></status>
</kw>
<kw type="for" name="${cNeighbor} IN [ @{current_neighbors} ]">
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712201.284385, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.705" level="INFO">{u'inactivity': 1545712201.284385, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 26, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629735.284663}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.202.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:07.706" starttime="20181224 22:35:07.705"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:07.707" level="INFO">1.1.1.101 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:07.707" starttime="20181224 22:35:07.707"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.707" starttime="20181224 22:35:07.707"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.708" starttime="20181224 22:35:07.706"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.708" starttime="20181224 22:35:07.706"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.709" starttime="20181224 22:35:07.709"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.709" starttime="20181224 22:35:07.708"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.709" starttime="20181224 22:35:07.708"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:07.709" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:35:07.709" level="INFO">${established_neighbors_length} = 1</msg>
<status status="PASS" endtime="20181224 22:35:07.710" starttime="20181224 22:35:07.709"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.710" level="INFO">[u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:07.710" starttime="20181224 22:35:07.710"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.710" starttime="20181224 22:35:07.710"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.711" starttime="20181224 22:35:07.711"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.711" starttime="20181224 22:35:07.711"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.711" starttime="20181224 22:35:07.705"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712202.286125, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.712" level="INFO">{u'inactivity': 1545712202.286125, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 31, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545629733.28634}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.202.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:07.712" starttime="20181224 22:35:07.712"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:07.714" level="INFO">1.1.1.102 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:07.714" starttime="20181224 22:35:07.713"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.714" starttime="20181224 22:35:07.713"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.714" starttime="20181224 22:35:07.712"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.714" starttime="20181224 22:35:07.712"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.715" starttime="20181224 22:35:07.715"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.715" starttime="20181224 22:35:07.714"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.715" starttime="20181224 22:35:07.714"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:07.716" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:35:07.716" level="INFO">${established_neighbors_length} = 2</msg>
<status status="PASS" endtime="20181224 22:35:07.716" starttime="20181224 22:35:07.715"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.716" level="INFO">[u'1.1.1.101', u'1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:07.716" starttime="20181224 22:35:07.716"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.716" starttime="20181224 22:35:07.716"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.717" starttime="20181224 22:35:07.717"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.717" starttime="20181224 22:35:07.717"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.717" starttime="20181224 22:35:07.711"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712209.288396, u'priority': 1, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'bac...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.718" level="INFO">{u'inactivity': 1545712209.288396, u'priority': 1, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.201', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545709872.288602}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.254', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:07.718" starttime="20181224 22:35:07.717"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:07.720" level="INFO">1.1.1.201 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:07.720" starttime="20181224 22:35:07.719"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.720" starttime="20181224 22:35:07.719"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.720" starttime="20181224 22:35:07.718"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.720" starttime="20181224 22:35:07.718"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.721" starttime="20181224 22:35:07.721"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.721" starttime="20181224 22:35:07.720"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.721" starttime="20181224 22:35:07.720"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:07.722" level="INFO">Length is 3</msg>
<msg timestamp="20181224 22:35:07.722" level="INFO">${established_neighbors_length} = 3</msg>
<status status="PASS" endtime="20181224 22:35:07.722" starttime="20181224 22:35:07.721"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.722" level="INFO">[u'1.1.1.101', u'1.1.1.102', u'1.1.1.201']</msg>
<status status="PASS" endtime="20181224 22:35:07.722" starttime="20181224 22:35:07.722"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.722" starttime="20181224 22:35:07.722"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.723" starttime="20181224 22:35:07.723"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.723" starttime="20181224 22:35:07.723"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.723" starttime="20181224 22:35:07.717"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.723" starttime="20181224 22:35:07.705"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.724" level="INFO">[u'1.1.1.101', u'1.1.1.102', u'1.1.1.201']</msg>
<status status="PASS" endtime="20181224 22:35:07.724" starttime="20181224 22:35:07.723"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.724" level="INFO">['1.1.1.101', '1.1.1.102', '1.1.1.201']</msg>
<status status="PASS" endtime="20181224 22:35:07.724" starttime="20181224 22:35:07.724"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_neighbors} ]">
<kw type="foritem" name="${listObject} = 1.1.1.101">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.725" starttime="20181224 22:35:07.725"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.725" starttime="20181224 22:35:07.724"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.725" starttime="20181224 22:35:07.724"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.102">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.726" starttime="20181224 22:35:07.726"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.726" starttime="20181224 22:35:07.725"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.726" starttime="20181224 22:35:07.725"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.201">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.727" starttime="20181224 22:35:07.726"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.727" starttime="20181224 22:35:07.726"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.727" starttime="20181224 22:35:07.726"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.727" starttime="20181224 22:35:07.724"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.727" starttime="20181224 22:35:07.703"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.727" starttime="20181224 22:35:07.703"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.727" starttime="20181224 22:35:07.111"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:07.727" starttime="20181224 22:35:07.109"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-Leaf1">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:07.728" starttime="20181224 22:35:07.727"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:35:07.728" level="INFO">${switch_info} = {'username': 'admin', 'index': 6, 'node': Node(connection=EapiConnection(transport=https://10.255.255.201:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf1', 'host': '10.255.255.201', 'tran...</msg>
<status status="PASS" endtime="20181224 22:35:07.728" starttime="20181224 22:35:07.728"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.728" level="INFO">{'username': 'admin', 'index': 6, 'node': Node(connection=EapiConnection(transport=https://10.255.255.201:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf1', 'host': '10.255.255.201', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.201:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:35:07.728" starttime="20181224 22:35:07.728"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.729" level="INFO">DCA-Leaf1</msg>
<status status="PASS" endtime="20181224 22:35:07.729" starttime="20181224 22:35:07.729"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:35:07.729" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.201', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.202'], 'loopback': '1.1.1.201'}</msg>
<status status="PASS" endtime="20181224 22:35:07.729" starttime="20181224 22:35:07.729"></status>
</kw>
<kw name="Validate OSPF Neighbors" library="Validate_OSPF_Neighbors">
<doc>Validating OSPF Neighbors on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${leaf}</arg>
</arguments>
<kw name="Get Neighbors" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_neighbors}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show ip ospf neighbor</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:35:07.730" level="INFO">${cmd} = show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:35:07.730" starttime="20181224 22:35:07.730"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:35:07.731" level="INFO">show ip ospf neighbor</msg>
<status status="PASS" endtime="20181224 22:35:07.731" starttime="20181224 22:35:07.731"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:08.175" starttime="20181224 22:35:07.731"></status>
</kw>
<msg timestamp="20181224 22:35:08.175" level="INFO">${result} = [{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712202.495666, u'priority': 0, u'interfaceName': u'Ethernet2',...</msg>
<status status="PASS" endtime="20181224 22:35:08.175" starttime="20181224 22:35:07.731"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.176" level="INFO">{'command': 'show ip ospf neighbor', 'result': {u'vrfs': {u'default': {u'instList': {u'1': {u'ospfNeighborEntries': [{u'inactivity': 1545712202.495666, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 26, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.495939}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.201.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712209.497429, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545709873.497647}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.255', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712204.499809, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545711835.500027}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.201.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]}}}}}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:35:08.176" starttime="20181224 22:35:08.176"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']['vrfs']['default']['instList']['1']}</arg>
<arg>ospfNeighborEntries</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:35:08.177" level="INFO">${result_dict} = [{u'inactivity': 1545712202.495666, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:35:08.177" starttime="20181224 22:35:08.177"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.178" level="INFO">[{u'inactivity': 1545712202.495666, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 26, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.495939}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.201.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712209.497429, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545709873.497647}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.255', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712204.499809, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545711835.500027}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.201.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:35:08.178" starttime="20181224 22:35:08.178"></status>
</kw>
<msg timestamp="20181224 22:35:08.179" level="INFO">${current_neighbors} = [{u'inactivity': 1545712202.495666, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'b...</msg>
<status status="PASS" endtime="20181224 22:35:08.179" starttime="20181224 22:35:07.730"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.179" level="INFO">[{u'inactivity': 1545712202.495666, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 26, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.495939}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.201.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712209.497429, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545709873.497647}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.255', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}, {u'inactivity': 1545712204.499809, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545711835.500027}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.201.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}]</msg>
<status status="PASS" endtime="20181224 22:35:08.179" starttime="20181224 22:35:08.179"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>ospf_neighbors</arg>
</arguments>
<assign>
<var>@{target_neighbors}</var>
</assign>
<msg timestamp="20181224 22:35:08.180" level="INFO">@{target_neighbors} = [ 1.1.1.101 | 1.1.1.102 | 1.1.1.202 ]</msg>
<status status="PASS" endtime="20181224 22:35:08.180" starttime="20181224 22:35:08.180"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate OSPF Validation</arg>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Initiate OSPF Validation" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${current_neighbors}</arg>
<arg>@{target_neighbors}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_neighbors}</var>
</assign>
<msg timestamp="20181224 22:35:08.182" level="INFO">@{established_neighbors} = [ ]</msg>
<status status="PASS" endtime="20181224 22:35:08.182" starttime="20181224 22:35:08.181"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.182" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:35:08.182" starttime="20181224 22:35:08.182"></status>
</kw>
<kw type="for" name="${cNeighbor} IN [ @{current_neighbors} ]">
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712202.495666, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.183" level="INFO">{u'inactivity': 1545712202.495666, u'priority': 0, u'interfaceName': u'Ethernet2', u'routerId': u'1.1.1.102', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 26, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 7, u'stateTime': 1545629734.495939}, u'adjacencyState': u'full', u'interfaceAddress': u'10.102.201.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:08.183" starttime="20181224 22:35:08.182"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:08.185" level="INFO">1.1.1.102 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:08.185" starttime="20181224 22:35:08.185"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.185" starttime="20181224 22:35:08.184"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.185" starttime="20181224 22:35:08.183"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.185" starttime="20181224 22:35:08.183"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:08.187" starttime="20181224 22:35:08.186"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.187" starttime="20181224 22:35:08.186"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.187" starttime="20181224 22:35:08.185"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:08.187" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:35:08.187" level="INFO">${established_neighbors_length} = 1</msg>
<status status="PASS" endtime="20181224 22:35:08.187" starttime="20181224 22:35:08.187"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.188" level="INFO">[u'1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:08.188" starttime="20181224 22:35:08.188"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.188" starttime="20181224 22:35:08.187"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:08.189" starttime="20181224 22:35:08.188"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.189" starttime="20181224 22:35:08.188"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.189" starttime="20181224 22:35:08.182"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712209.497429, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'bac...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.189" level="INFO">{u'inactivity': 1545712209.497429, u'priority': 0, u'interfaceName': u'Vlan4094', u'routerId': u'1.1.1.202', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545709873.497647}, u'adjacencyState': u'full', u'interfaceAddress': u'192.168.255.255', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:08.189" starttime="20181224 22:35:08.189"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:08.191" level="INFO">1.1.1.202 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:08.191" starttime="20181224 22:35:08.191"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.191" starttime="20181224 22:35:08.190"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.191" starttime="20181224 22:35:08.190"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.191" starttime="20181224 22:35:08.190"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:08.193" starttime="20181224 22:35:08.192"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.193" starttime="20181224 22:35:08.192"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.193" starttime="20181224 22:35:08.192"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:08.193" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:35:08.193" level="INFO">${established_neighbors_length} = 2</msg>
<status status="PASS" endtime="20181224 22:35:08.193" starttime="20181224 22:35:08.193"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.194" level="INFO">[u'1.1.1.102', u'1.1.1.202']</msg>
<status status="PASS" endtime="20181224 22:35:08.194" starttime="20181224 22:35:08.194"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.194" starttime="20181224 22:35:08.194"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:08.195" starttime="20181224 22:35:08.195"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.195" starttime="20181224 22:35:08.194"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.195" starttime="20181224 22:35:08.189"></status>
</kw>
<kw type="foritem" name="${cNeighbor} = {u'inactivity': 1545712204.499809, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'ba...">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cNeighbor}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.195" level="INFO">{u'inactivity': 1545712204.499809, u'priority': 0, u'interfaceName': u'Ethernet1', u'routerId': u'1.1.1.101', u'drState': None, u'details': {u'grLastRestartTime': None, u'bfdState': u'adminDown', u'backupDesignatedRouter': u'0.0.0.0', u'retransmissionCount': 0, u'areaId': u'0.0.0.0', u'designatedRouter': u'0.0.0.0', u'grHelperTimer': None, u'grNumAttempts': 0, u'inactivityDefers': 0, u'bfdRequestSent': False, u'numberOfStateChanges': 6, u'stateTime': 1545711835.500027}, u'adjacencyState': u'full', u'interfaceAddress': u'10.101.201.0', u'options': {u'doNotUseInRouteCalc': False, u'demandCircuitsSupport': False, u'nssaCapability': False, u'opaqueLsaSupport': False, u'multitopologyCapability': False, u'externalRoutingCapability': True, u'linkLocalSignaling': False, u'multicastCapability': False}}</msg>
<status status="PASS" endtime="20181224 22:35:08.196" starttime="20181224 22:35:08.195"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>Pass OSPF Test</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Pass OSPF Test" library="Validate_OSPF_Neighbors">
<arguments>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${neighbor} adjacency is FULL</arg>
</arguments>
<msg timestamp="20181224 22:35:08.197" level="INFO">1.1.1.101 adjacency is FULL</msg>
<status status="PASS" endtime="20181224 22:35:08.197" starttime="20181224 22:35:08.197"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.198" starttime="20181224 22:35:08.197"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.198" starttime="20181224 22:35:08.196"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.198" starttime="20181224 22:35:08.196"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' in @{target_neighbors} and '${cNeighbor['adjacencyState']}'=='full'</arg>
<arg>append to list</arg>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_neighbors}</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:08.199" starttime="20181224 22:35:08.199"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.199" starttime="20181224 22:35:08.198"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.199" starttime="20181224 22:35:08.198"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<assign>
<var>${established_neighbors_length}</var>
</assign>
<msg timestamp="20181224 22:35:08.199" level="INFO">Length is 3</msg>
<msg timestamp="20181224 22:35:08.199" level="INFO">${established_neighbors_length} = 3</msg>
<status status="PASS" endtime="20181224 22:35:08.199" starttime="20181224 22:35:08.199"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_neighbors_length} != 0</arg>
<arg>Log</arg>
<arg>${established_neighbors}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.200" level="INFO">[u'1.1.1.102', u'1.1.1.202', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:08.200" starttime="20181224 22:35:08.200"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.200" starttime="20181224 22:35:08.200"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cNeighbor['routerId']}' not in @{target_neighbors}</arg>
<arg>Fail Test Additional Neighbor</arg>
<arg>${cNeighbor['routerId']}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:08.201" starttime="20181224 22:35:08.201"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.201" starttime="20181224 22:35:08.200"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.201" starttime="20181224 22:35:08.195"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.201" starttime="20181224 22:35:08.182"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.201" level="INFO">[u'1.1.1.102', u'1.1.1.202', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:08.201" starttime="20181224 22:35:08.201"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_neighbors}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.202" level="INFO">['1.1.1.101', '1.1.1.102', '1.1.1.202']</msg>
<status status="PASS" endtime="20181224 22:35:08.202" starttime="20181224 22:35:08.202"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_neighbors} ]">
<kw type="foritem" name="${listObject} = 1.1.1.101">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:08.203" starttime="20181224 22:35:08.202"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.203" starttime="20181224 22:35:08.202"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.203" starttime="20181224 22:35:08.202"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.102">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:08.203" starttime="20181224 22:35:08.203"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.204" starttime="20181224 22:35:08.203"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.204" starttime="20181224 22:35:08.203"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.202">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_neighbors}</arg>
<arg>Fail Test Neighbor List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:08.204" starttime="20181224 22:35:08.204"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.204" starttime="20181224 22:35:08.204"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.204" starttime="20181224 22:35:08.204"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.204" starttime="20181224 22:35:08.202"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.205" starttime="20181224 22:35:08.181"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.205" starttime="20181224 22:35:08.180"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.205" starttime="20181224 22:35:07.729"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.205" starttime="20181224 22:35:07.727"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:08.205" starttime="20181224 22:35:05.838"></status>
</kw>
<doc>Validate OSPF Neighbors for Leafs</doc>
<tags>
<tag>LEAF_OSPF</tag>
</tags>
<status status="PASS" endtime="20181224 22:35:08.205" critical="yes" starttime="20181224 22:35:05.837"></status>
</test>
<test id="s1-t6" name="Leaf EVPN Peering Validation">
<kw type="for" name="${leaf} IN [ @{leafs} ]">
<kw type="foritem" name="${leaf} = DCA-BL2">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:08.206" starttime="20181224 22:35:08.206"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:35:08.206" level="INFO">${switch_info} = {'username': 'admin', 'index': 3, 'node': Node(connection=EapiConnection(transport=https://10.255.255.204:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL2', 'host': '10.255.255.204', 'transp...</msg>
<status status="PASS" endtime="20181224 22:35:08.207" starttime="20181224 22:35:08.206"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.207" level="INFO">{'username': 'admin', 'index': 3, 'node': Node(connection=EapiConnection(transport=https://10.255.255.204:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL2', 'host': '10.255.255.204', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.204:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:35:08.207" starttime="20181224 22:35:08.207"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.207" level="INFO">DCA-BL2</msg>
<status status="PASS" endtime="20181224 22:35:08.207" starttime="20181224 22:35:08.207"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:35:08.208" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.204', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.203'], 'loopback': '1.1.1.204'}</msg>
<status status="PASS" endtime="20181224 22:35:08.208" starttime="20181224 22:35:08.208"></status>
</kw>
<kw name="Validate EVPN Peerings" library="Validate_EVPN_Peerings">
<doc>Validating EVPN Peerings on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${leaf}</arg>
</arguments>
<kw name="Get Peers" library="Validate_EVPN_Peerings">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_peers}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show bgp evpn summary</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:35:08.209" level="INFO">${cmd} = show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:35:08.209" starttime="20181224 22:35:08.209"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:35:08.209" level="INFO">show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:35:08.209" starttime="20181224 22:35:08.209"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:09.239" starttime="20181224 22:35:08.210"></status>
</kw>
<msg timestamp="20181224 22:35:09.239" level="INFO">${result} = [{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.204', u'peers': {u'1.1.1.102': {u'msgSent': 7248, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629742.341953, u'ver...</msg>
<status status="PASS" endtime="20181224 22:35:09.239" starttime="20181224 22:35:08.209"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.240" level="INFO">{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.204', u'peers': {u'1.1.1.102': {u'msgSent': 7248, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629742.341953, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7381, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7342, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629744.747107, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7355, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}, u'vrf': u'default', u'asn': 65102}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:35:09.240" starttime="20181224 22:35:09.239"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']}</arg>
<arg>peers</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:35:09.241" level="INFO">${result_dict} = {u'1.1.1.102': {u'msgSent': 7248, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629742.341953, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7381, u'peerState': u'Established', u...</msg>
<status status="PASS" endtime="20181224 22:35:09.241" starttime="20181224 22:35:09.240"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.241" level="INFO">{u'1.1.1.102': {u'msgSent': 7248, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629742.341953, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7381, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7342, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629744.747107, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7355, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}</msg>
<status status="PASS" endtime="20181224 22:35:09.241" starttime="20181224 22:35:09.241"></status>
</kw>
<msg timestamp="20181224 22:35:09.242" level="INFO">${current_peers} = {u'1.1.1.102': {u'msgSent': 7248, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629742.341953, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7381, u'peerState': u'Established', u...</msg>
<status status="PASS" endtime="20181224 22:35:09.242" starttime="20181224 22:35:08.208"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.242" level="INFO">{u'1.1.1.102': {u'msgSent': 7248, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629742.341953, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7381, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7342, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629744.747107, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7355, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}</msg>
<status status="PASS" endtime="20181224 22:35:09.242" starttime="20181224 22:35:09.242"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>evpn_peers</arg>
</arguments>
<assign>
<var>@{target_peers}</var>
</assign>
<msg timestamp="20181224 22:35:09.243" level="INFO">@{target_peers} = [ 1.1.1.101 | 1.1.1.102 ]</msg>
<status status="PASS" endtime="20181224 22:35:09.243" starttime="20181224 22:35:09.243"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate EVPN Validation</arg>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Initiate EVPN Validation" library="Validate_EVPN_Peerings">
<arguments>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_peers}</var>
</assign>
<msg timestamp="20181224 22:35:09.245" level="INFO">@{established_peers} = [ ]</msg>
<status status="PASS" endtime="20181224 22:35:09.245" starttime="20181224 22:35:09.244"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.245" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:35:09.245" starttime="20181224 22:35:09.245"></status>
</kw>
<kw type="for" name="${cPeer} IN [ @{current_peers} ]">
<kw type="foritem" name="${cPeer} = 1.1.1.102">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.246" level="INFO">1.1.1.102</msg>
<status status="PASS" endtime="20181224 22:35:09.246" starttime="20181224 22:35:09.246"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.246" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:35:09.246" starttime="20181224 22:35:09.246"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:35:09.248" level="INFO">1.1.1.102 is Established</msg>
<status status="PASS" endtime="20181224 22:35:09.248" starttime="20181224 22:35:09.248"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.249" starttime="20181224 22:35:09.248"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.249" starttime="20181224 22:35:09.247"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.249" starttime="20181224 22:35:09.247"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:09.250" starttime="20181224 22:35:09.250"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.250" starttime="20181224 22:35:09.249"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.250" starttime="20181224 22:35:09.249"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:35:09.250" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:35:09.251" level="INFO">${established_peers_length} = 1</msg>
<status status="PASS" endtime="20181224 22:35:09.251" starttime="20181224 22:35:09.250"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.251" level="INFO">[u'1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:09.251" starttime="20181224 22:35:09.251"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.251" starttime="20181224 22:35:09.251"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:09.252" starttime="20181224 22:35:09.252"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.252" starttime="20181224 22:35:09.252"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.252" starttime="20181224 22:35:09.245"></status>
</kw>
<kw type="foritem" name="${cPeer} = 1.1.1.101">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.253" level="INFO">1.1.1.101</msg>
<status status="PASS" endtime="20181224 22:35:09.253" starttime="20181224 22:35:09.252"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.253" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:35:09.253" starttime="20181224 22:35:09.253"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:35:09.255" level="INFO">1.1.1.101 is Established</msg>
<status status="PASS" endtime="20181224 22:35:09.255" starttime="20181224 22:35:09.255"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.255" starttime="20181224 22:35:09.254"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.255" starttime="20181224 22:35:09.254"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.255" starttime="20181224 22:35:09.253"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:09.256" starttime="20181224 22:35:09.256"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.256" starttime="20181224 22:35:09.256"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.256" starttime="20181224 22:35:09.255"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:35:09.257" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:35:09.257" level="INFO">${established_peers_length} = 2</msg>
<status status="PASS" endtime="20181224 22:35:09.257" starttime="20181224 22:35:09.257"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.258" level="INFO">[u'1.1.1.102', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:09.258" starttime="20181224 22:35:09.258"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.258" starttime="20181224 22:35:09.257"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:09.259" starttime="20181224 22:35:09.258"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.259" starttime="20181224 22:35:09.258"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.259" starttime="20181224 22:35:09.252"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.259" starttime="20181224 22:35:09.245"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.259" level="INFO">[u'1.1.1.102', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:09.259" starttime="20181224 22:35:09.259"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.259" level="INFO">['1.1.1.101', '1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:09.259" starttime="20181224 22:35:09.259"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_peers} ]">
<kw type="foritem" name="${listObject} = 1.1.1.101">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:09.260" starttime="20181224 22:35:09.260"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.260" starttime="20181224 22:35:09.260"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.260" starttime="20181224 22:35:09.260"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.102">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:09.261" starttime="20181224 22:35:09.261"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.261" starttime="20181224 22:35:09.260"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.261" starttime="20181224 22:35:09.260"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.261" starttime="20181224 22:35:09.259"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.261" starttime="20181224 22:35:09.244"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.261" starttime="20181224 22:35:09.244"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.261" starttime="20181224 22:35:08.208"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:09.261" starttime="20181224 22:35:08.206"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-BL1">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:09.262" starttime="20181224 22:35:09.262"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:35:09.262" level="INFO">${switch_info} = {'username': 'admin', 'index': 4, 'node': Node(connection=EapiConnection(transport=https://10.255.255.203:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL1', 'host': '10.255.255.203', 'transp...</msg>
<status status="PASS" endtime="20181224 22:35:09.262" starttime="20181224 22:35:09.262"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.263" level="INFO">{'username': 'admin', 'index': 4, 'node': Node(connection=EapiConnection(transport=https://10.255.255.203:443//command-api)), 'autorefresh': True, 'alias': 'DCA-BL1', 'host': '10.255.255.203', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.203:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:35:09.263" starttime="20181224 22:35:09.262"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.263" level="INFO">DCA-BL1</msg>
<status status="PASS" endtime="20181224 22:35:09.263" starttime="20181224 22:35:09.263"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:35:09.263" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.203', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.204'], 'loopback': '1.1.1.203'}</msg>
<status status="PASS" endtime="20181224 22:35:09.263" starttime="20181224 22:35:09.263"></status>
</kw>
<kw name="Validate EVPN Peerings" library="Validate_EVPN_Peerings">
<doc>Validating EVPN Peerings on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${leaf}</arg>
</arguments>
<kw name="Get Peers" library="Validate_EVPN_Peerings">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_peers}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show bgp evpn summary</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:35:09.264" level="INFO">${cmd} = show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:35:09.264" starttime="20181224 22:35:09.264"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:35:09.265" level="INFO">show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:35:09.265" starttime="20181224 22:35:09.265"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:10.296" starttime="20181224 22:35:09.265"></status>
</kw>
<msg timestamp="20181224 22:35:10.296" level="INFO">${result} = [{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.203', u'peers': {u'1.1.1.102': {u'msgSent': 7333, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629736.9449625, u've...</msg>
<status status="PASS" endtime="20181224 22:35:10.296" starttime="20181224 22:35:09.265"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.297" level="INFO">{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.203', u'peers': {u'1.1.1.102': {u'msgSent': 7333, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629736.9449625, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7376, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7265, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629732.2563674, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7331, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}, u'vrf': u'default', u'asn': 65102}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:35:10.297" starttime="20181224 22:35:10.297"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']}</arg>
<arg>peers</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:35:10.298" level="INFO">${result_dict} = {u'1.1.1.102': {u'msgSent': 7333, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629736.9449625, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7376, u'peerState': u'Established', ...</msg>
<status status="PASS" endtime="20181224 22:35:10.298" starttime="20181224 22:35:10.298"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.299" level="INFO">{u'1.1.1.102': {u'msgSent': 7333, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629736.9449625, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7376, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7265, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629732.2563674, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7331, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}</msg>
<status status="PASS" endtime="20181224 22:35:10.299" starttime="20181224 22:35:10.298"></status>
</kw>
<msg timestamp="20181224 22:35:10.299" level="INFO">${current_peers} = {u'1.1.1.102': {u'msgSent': 7333, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629736.9449625, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7376, u'peerState': u'Established', ...</msg>
<status status="PASS" endtime="20181224 22:35:10.299" starttime="20181224 22:35:09.264"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.300" level="INFO">{u'1.1.1.102': {u'msgSent': 7333, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629736.9449625, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7376, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7265, u'inMsgQueue': 0, u'prefixReceived': 10, u'upDownTime': 1545629732.2563674, u'version': 4, u'prefixAccepted': 10, u'msgReceived': 7331, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}</msg>
<status status="PASS" endtime="20181224 22:35:10.300" starttime="20181224 22:35:10.299"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>evpn_peers</arg>
</arguments>
<assign>
<var>@{target_peers}</var>
</assign>
<msg timestamp="20181224 22:35:10.301" level="INFO">@{target_peers} = [ 1.1.1.101 | 1.1.1.102 ]</msg>
<status status="PASS" endtime="20181224 22:35:10.301" starttime="20181224 22:35:10.300"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate EVPN Validation</arg>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Initiate EVPN Validation" library="Validate_EVPN_Peerings">
<arguments>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_peers}</var>
</assign>
<msg timestamp="20181224 22:35:10.302" level="INFO">@{established_peers} = [ ]</msg>
<status status="PASS" endtime="20181224 22:35:10.302" starttime="20181224 22:35:10.302"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.302" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:35:10.303" starttime="20181224 22:35:10.302"></status>
</kw>
<kw type="for" name="${cPeer} IN [ @{current_peers} ]">
<kw type="foritem" name="${cPeer} = 1.1.1.102">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.303" level="INFO">1.1.1.102</msg>
<status status="PASS" endtime="20181224 22:35:10.303" starttime="20181224 22:35:10.303"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.304" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:35:10.304" starttime="20181224 22:35:10.303"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:35:10.306" level="INFO">1.1.1.102 is Established</msg>
<status status="PASS" endtime="20181224 22:35:10.306" starttime="20181224 22:35:10.306"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.306" starttime="20181224 22:35:10.305"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.306" starttime="20181224 22:35:10.305"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.306" starttime="20181224 22:35:10.304"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:10.308" starttime="20181224 22:35:10.307"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.308" starttime="20181224 22:35:10.307"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.308" starttime="20181224 22:35:10.307"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:35:10.308" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:35:10.308" level="INFO">${established_peers_length} = 1</msg>
<status status="PASS" endtime="20181224 22:35:10.308" starttime="20181224 22:35:10.308"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.309" level="INFO">[u'1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:10.309" starttime="20181224 22:35:10.309"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.309" starttime="20181224 22:35:10.308"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:10.310" starttime="20181224 22:35:10.310"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.310" starttime="20181224 22:35:10.309"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.310" starttime="20181224 22:35:10.303"></status>
</kw>
<kw type="foritem" name="${cPeer} = 1.1.1.101">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.310" level="INFO">1.1.1.101</msg>
<status status="PASS" endtime="20181224 22:35:10.310" starttime="20181224 22:35:10.310"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.311" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:35:10.311" starttime="20181224 22:35:10.311"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:35:10.313" level="INFO">1.1.1.101 is Established</msg>
<status status="PASS" endtime="20181224 22:35:10.313" starttime="20181224 22:35:10.312"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.313" starttime="20181224 22:35:10.312"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.313" starttime="20181224 22:35:10.312"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.313" starttime="20181224 22:35:10.311"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:10.314" starttime="20181224 22:35:10.314"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.314" starttime="20181224 22:35:10.313"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.314" starttime="20181224 22:35:10.313"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:35:10.315" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:35:10.315" level="INFO">${established_peers_length} = 2</msg>
<status status="PASS" endtime="20181224 22:35:10.315" starttime="20181224 22:35:10.314"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.316" level="INFO">[u'1.1.1.102', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:10.316" starttime="20181224 22:35:10.315"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.316" starttime="20181224 22:35:10.315"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:10.316" starttime="20181224 22:35:10.316"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.316" starttime="20181224 22:35:10.316"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.316" starttime="20181224 22:35:10.310"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.316" starttime="20181224 22:35:10.303"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.317" level="INFO">[u'1.1.1.102', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:10.317" starttime="20181224 22:35:10.317"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.317" level="INFO">['1.1.1.101', '1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:10.317" starttime="20181224 22:35:10.317"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_peers} ]">
<kw type="foritem" name="${listObject} = 1.1.1.101">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:10.318" starttime="20181224 22:35:10.318"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.318" starttime="20181224 22:35:10.318"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.318" starttime="20181224 22:35:10.317"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.102">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:10.319" starttime="20181224 22:35:10.319"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.319" starttime="20181224 22:35:10.318"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.319" starttime="20181224 22:35:10.318"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.319" starttime="20181224 22:35:10.317"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.319" starttime="20181224 22:35:10.301"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.319" starttime="20181224 22:35:10.301"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.319" starttime="20181224 22:35:09.264"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:10.319" starttime="20181224 22:35:09.261"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-Leaf2">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:10.320" starttime="20181224 22:35:10.320"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:35:10.320" level="INFO">${switch_info} = {'username': 'admin', 'index': 5, 'node': Node(connection=EapiConnection(transport=https://10.255.255.202:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf2', 'host': '10.255.255.202', 'tran...</msg>
<status status="PASS" endtime="20181224 22:35:10.320" starttime="20181224 22:35:10.320"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.321" level="INFO">{'username': 'admin', 'index': 5, 'node': Node(connection=EapiConnection(transport=https://10.255.255.202:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf2', 'host': '10.255.255.202', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.202:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:35:10.321" starttime="20181224 22:35:10.320"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.321" level="INFO">DCA-Leaf2</msg>
<status status="PASS" endtime="20181224 22:35:10.321" starttime="20181224 22:35:10.321"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:35:10.321" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.202', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.201'], 'loopback': '1.1.1.202'}</msg>
<status status="PASS" endtime="20181224 22:35:10.321" starttime="20181224 22:35:10.321"></status>
</kw>
<kw name="Validate EVPN Peerings" library="Validate_EVPN_Peerings">
<doc>Validating EVPN Peerings on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${leaf}</arg>
</arguments>
<kw name="Get Peers" library="Validate_EVPN_Peerings">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_peers}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show bgp evpn summary</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:35:10.323" level="INFO">${cmd} = show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:35:10.323" starttime="20181224 22:35:10.323"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:35:10.323" level="INFO">show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:35:10.323" starttime="20181224 22:35:10.323"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:11.303" starttime="20181224 22:35:10.324"></status>
</kw>
<msg timestamp="20181224 22:35:11.303" level="INFO">${result} = [{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.202', u'peers': {u'1.1.1.102': {u'msgSent': 7249, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.6411, u'versio...</msg>
<status status="PASS" endtime="20181224 22:35:11.303" starttime="20181224 22:35:10.323"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.304" level="INFO">{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.202', u'peers': {u'1.1.1.102': {u'msgSent': 7249, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.6411, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7255, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7238, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629743.3197055, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7233, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}, u'vrf': u'default', u'asn': 65101}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:35:11.304" starttime="20181224 22:35:11.303"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']}</arg>
<arg>peers</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:35:11.305" level="INFO">${result_dict} = {u'1.1.1.102': {u'msgSent': 7249, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.6411, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7255, u'peerState': u'Established', u'out...</msg>
<status status="PASS" endtime="20181224 22:35:11.305" starttime="20181224 22:35:11.304"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.305" level="INFO">{u'1.1.1.102': {u'msgSent': 7249, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.6411, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7255, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7238, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629743.3197055, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7233, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}</msg>
<status status="PASS" endtime="20181224 22:35:11.305" starttime="20181224 22:35:11.305"></status>
</kw>
<msg timestamp="20181224 22:35:11.306" level="INFO">${current_peers} = {u'1.1.1.102': {u'msgSent': 7249, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.6411, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7255, u'peerState': u'Established', u'out...</msg>
<status status="PASS" endtime="20181224 22:35:11.306" starttime="20181224 22:35:10.322"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.306" level="INFO">{u'1.1.1.102': {u'msgSent': 7249, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.6411, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7255, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7238, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629743.3197055, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7233, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}</msg>
<status status="PASS" endtime="20181224 22:35:11.306" starttime="20181224 22:35:11.306"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>evpn_peers</arg>
</arguments>
<assign>
<var>@{target_peers}</var>
</assign>
<msg timestamp="20181224 22:35:11.307" level="INFO">@{target_peers} = [ 1.1.1.101 | 1.1.1.102 ]</msg>
<status status="PASS" endtime="20181224 22:35:11.307" starttime="20181224 22:35:11.307"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate EVPN Validation</arg>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Initiate EVPN Validation" library="Validate_EVPN_Peerings">
<arguments>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_peers}</var>
</assign>
<msg timestamp="20181224 22:35:11.309" level="INFO">@{established_peers} = [ ]</msg>
<status status="PASS" endtime="20181224 22:35:11.309" starttime="20181224 22:35:11.308"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.309" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:35:11.309" starttime="20181224 22:35:11.309"></status>
</kw>
<kw type="for" name="${cPeer} IN [ @{current_peers} ]">
<kw type="foritem" name="${cPeer} = 1.1.1.102">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.310" level="INFO">1.1.1.102</msg>
<status status="PASS" endtime="20181224 22:35:11.310" starttime="20181224 22:35:11.309"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.310" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:35:11.310" starttime="20181224 22:35:11.310"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:35:11.312" level="INFO">1.1.1.102 is Established</msg>
<status status="PASS" endtime="20181224 22:35:11.312" starttime="20181224 22:35:11.312"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.312" starttime="20181224 22:35:11.312"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.312" starttime="20181224 22:35:11.311"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.313" starttime="20181224 22:35:11.311"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:11.314" starttime="20181224 22:35:11.314"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.314" starttime="20181224 22:35:11.313"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.314" starttime="20181224 22:35:11.313"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:35:11.314" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:35:11.315" level="INFO">${established_peers_length} = 1</msg>
<status status="PASS" endtime="20181224 22:35:11.315" starttime="20181224 22:35:11.314"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.315" level="INFO">[u'1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:11.315" starttime="20181224 22:35:11.315"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.315" starttime="20181224 22:35:11.315"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:11.316" starttime="20181224 22:35:11.316"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.316" starttime="20181224 22:35:11.316"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.316" starttime="20181224 22:35:11.309"></status>
</kw>
<kw type="foritem" name="${cPeer} = 1.1.1.101">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.317" level="INFO">1.1.1.101</msg>
<status status="PASS" endtime="20181224 22:35:11.317" starttime="20181224 22:35:11.317"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.317" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:35:11.317" starttime="20181224 22:35:11.317"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:35:11.319" level="INFO">1.1.1.101 is Established</msg>
<status status="PASS" endtime="20181224 22:35:11.319" starttime="20181224 22:35:11.319"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.319" starttime="20181224 22:35:11.318"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.319" starttime="20181224 22:35:11.318"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.319" starttime="20181224 22:35:11.318"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:11.320" starttime="20181224 22:35:11.320"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.321" starttime="20181224 22:35:11.320"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.321" starttime="20181224 22:35:11.319"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:35:11.321" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:35:11.321" level="INFO">${established_peers_length} = 2</msg>
<status status="PASS" endtime="20181224 22:35:11.321" starttime="20181224 22:35:11.321"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.322" level="INFO">[u'1.1.1.102', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:11.322" starttime="20181224 22:35:11.322"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.322" starttime="20181224 22:35:11.321"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:11.323" starttime="20181224 22:35:11.322"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.323" starttime="20181224 22:35:11.322"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.323" starttime="20181224 22:35:11.316"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.323" starttime="20181224 22:35:11.309"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.323" level="INFO">[u'1.1.1.102', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:11.323" starttime="20181224 22:35:11.323"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.323" level="INFO">['1.1.1.101', '1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:11.324" starttime="20181224 22:35:11.323"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_peers} ]">
<kw type="foritem" name="${listObject} = 1.1.1.101">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:11.324" starttime="20181224 22:35:11.324"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.324" starttime="20181224 22:35:11.324"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.324" starttime="20181224 22:35:11.324"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.102">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:11.325" starttime="20181224 22:35:11.325"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.325" starttime="20181224 22:35:11.325"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.325" starttime="20181224 22:35:11.325"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.325" starttime="20181224 22:35:11.324"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.325" starttime="20181224 22:35:11.308"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.325" starttime="20181224 22:35:11.307"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.326" starttime="20181224 22:35:10.322"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:11.326" starttime="20181224 22:35:10.319"></status>
</kw>
<kw type="foritem" name="${leaf} = DCA-Leaf1">
<kw name="Change To Switch" library="AristaLibrary">
<doc>Change To Switch changes the active switch for all following keywords.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:11.326" starttime="20181224 22:35:11.326"></status>
</kw>
<kw name="Get Switch" library="AristaLibrary">
<doc>Get Switch returns a dictionary of information about the active
switch connection. Details include the host, username, password,
transport and port.</doc>
<assign>
<var>${switch_info}</var>
</assign>
<msg timestamp="20181224 22:35:11.326" level="INFO">${switch_info} = {'username': 'admin', 'index': 6, 'node': Node(connection=EapiConnection(transport=https://10.255.255.201:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf1', 'host': '10.255.255.201', 'tran...</msg>
<status status="PASS" endtime="20181224 22:35:11.326" starttime="20181224 22:35:11.326"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${switch_info}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.327" level="INFO">{'username': 'admin', 'index': 6, 'node': Node(connection=EapiConnection(transport=https://10.255.255.201:443//command-api)), 'autorefresh': True, 'alias': 'DCA-Leaf1', 'host': '10.255.255.201', 'transport': 'https', 'password': 'arista', 'port': 443, 'conn': EapiConnection(transport=https://10.255.255.201:443//command-api)}</msg>
<status status="PASS" endtime="20181224 22:35:11.327" starttime="20181224 22:35:11.326"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${leaf}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.327" level="INFO">DCA-Leaf1</msg>
<status status="PASS" endtime="20181224 22:35:11.327" starttime="20181224 22:35:11.327"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${leafs}</arg>
<arg>${leaf}</arg>
</arguments>
<assign>
<var>${target_dictionary}</var>
</assign>
<msg timestamp="20181224 22:35:11.328" level="INFO">${target_dictionary} = {'management_ip': '10.255.255.201', 'evpn_peers': ['1.1.1.101', '1.1.1.102'], 'ospf_neighbors': ['1.1.1.101', '1.1.1.102', '1.1.1.202'], 'loopback': '1.1.1.201'}</msg>
<status status="PASS" endtime="20181224 22:35:11.328" starttime="20181224 22:35:11.327"></status>
</kw>
<kw name="Validate EVPN Peerings" library="Validate_EVPN_Peerings">
<doc>Validating EVPN Peerings on Switches</doc>
<arguments>
<arg>${target_dictionary}</arg>
<arg>${leaf}</arg>
</arguments>
<kw name="Get Peers" library="Validate_EVPN_Peerings">
<arguments>
<arg>${switch}</arg>
</arguments>
<assign>
<var>${current_peers}</var>
</assign>
<kw name="Set Variable" library="BuiltIn">
<doc>Returns the given values which can then be assigned to a variables.</doc>
<arguments>
<arg>show bgp evpn summary</arg>
</arguments>
<assign>
<var>${cmd}</var>
</assign>
<msg timestamp="20181224 22:35:11.329" level="INFO">${cmd} = show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:35:11.329" starttime="20181224 22:35:11.328"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<msg timestamp="20181224 22:35:11.329" level="INFO">show bgp evpn summary</msg>
<status status="PASS" endtime="20181224 22:35:11.329" starttime="20181224 22:35:11.329"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Enable</arg>
<arg>${cmd}</arg>
</arguments>
<assign>
<var>${result}</var>
</assign>
<kw name="Enable" library="AristaLibrary">
<doc>The Enable keyword lets you run a list of commands in enable mode.
It returns a list containing the list of commands, output of those
commands and the encoding used. It uses the pyeapi Node.enable()
function. If a command fails due to an encoding error, then the command
set will be re-issued individual with text encoding.</doc>
<arguments>
<arg>${cmd}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:12.346" starttime="20181224 22:35:11.329"></status>
</kw>
<msg timestamp="20181224 22:35:12.346" level="INFO">${result} = [{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.201', u'peers': {u'1.1.1.102': {u'msgSent': 7265, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.541416, u'vers...</msg>
<status status="PASS" endtime="20181224 22:35:12.347" starttime="20181224 22:35:11.329"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result[0]}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.347" level="INFO">{'command': 'show bgp evpn summary', 'result': {u'routerId': u'1.1.1.201', u'peers': {u'1.1.1.102': {u'msgSent': 7265, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.541416, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7263, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7263, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629738.3294415, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7273, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}, u'vrf': u'default', u'asn': 65101}, 'encoding': 'json'}</msg>
<status status="PASS" endtime="20181224 22:35:12.348" starttime="20181224 22:35:12.347"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${result[0]['result']}</arg>
<arg>peers</arg>
</arguments>
<assign>
<var>${result_dict}</var>
</assign>
<msg timestamp="20181224 22:35:12.349" level="INFO">${result_dict} = {u'1.1.1.102': {u'msgSent': 7265, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.541416, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7263, u'peerState': u'Established', u'o...</msg>
<status status="PASS" endtime="20181224 22:35:12.349" starttime="20181224 22:35:12.348"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${result_dict}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.349" level="INFO">{u'1.1.1.102': {u'msgSent': 7265, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.541416, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7263, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7263, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629738.3294415, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7273, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}</msg>
<status status="PASS" endtime="20181224 22:35:12.349" starttime="20181224 22:35:12.349"></status>
</kw>
<msg timestamp="20181224 22:35:12.350" level="INFO">${current_peers} = {u'1.1.1.102': {u'msgSent': 7265, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.541416, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7263, u'peerState': u'Established', u'o...</msg>
<status status="PASS" endtime="20181224 22:35:12.350" starttime="20181224 22:35:11.328"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${current_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.350" level="INFO">{u'1.1.1.102': {u'msgSent': 7265, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629740.541416, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7263, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}, u'1.1.1.101': {u'msgSent': 7263, u'inMsgQueue': 0, u'prefixReceived': 8, u'upDownTime': 1545629738.3294415, u'version': 4, u'prefixAccepted': 8, u'msgReceived': 7273, u'peerState': u'Established', u'outMsgQueue': 0, u'underMaintenance': False, u'asn': 65100}}</msg>
<status status="PASS" endtime="20181224 22:35:12.350" starttime="20181224 22:35:12.350"></status>
</kw>
<kw name="Get From Dictionary" library="Collections">
<doc>Returns a value from the given ``dictionary`` based on the given ``key``.</doc>
<arguments>
<arg>${target_container}</arg>
<arg>evpn_peers</arg>
</arguments>
<assign>
<var>@{target_peers}</var>
</assign>
<msg timestamp="20181224 22:35:12.351" level="INFO">@{target_peers} = [ 1.1.1.101 | 1.1.1.102 ]</msg>
<status status="PASS" endtime="20181224 22:35:12.351" starttime="20181224 22:35:12.350"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Initiate EVPN Validation</arg>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Initiate EVPN Validation" library="Validate_EVPN_Peerings">
<arguments>
<arg>${current_peers}</arg>
<arg>@{target_peers}</arg>
</arguments>
<kw name="Create List" library="BuiltIn">
<doc>Returns a list containing given items.</doc>
<assign>
<var>@{established_peers}</var>
</assign>
<msg timestamp="20181224 22:35:12.352" level="INFO">@{established_peers} = [ ]</msg>
<status status="PASS" endtime="20181224 22:35:12.352" starttime="20181224 22:35:12.352"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.353" level="INFO">[]</msg>
<status status="PASS" endtime="20181224 22:35:12.353" starttime="20181224 22:35:12.352"></status>
</kw>
<kw type="for" name="${cPeer} IN [ @{current_peers} ]">
<kw type="foritem" name="${cPeer} = 1.1.1.102">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.353" level="INFO">1.1.1.102</msg>
<status status="PASS" endtime="20181224 22:35:12.353" starttime="20181224 22:35:12.353"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.354" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:35:12.354" starttime="20181224 22:35:12.354"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:35:12.356" level="INFO">1.1.1.102 is Established</msg>
<status status="PASS" endtime="20181224 22:35:12.356" starttime="20181224 22:35:12.356"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.356" starttime="20181224 22:35:12.355"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.356" starttime="20181224 22:35:12.355"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.356" starttime="20181224 22:35:12.354"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:12.357" starttime="20181224 22:35:12.357"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.358" starttime="20181224 22:35:12.357"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.358" starttime="20181224 22:35:12.356"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:35:12.358" level="INFO">Length is 1</msg>
<msg timestamp="20181224 22:35:12.358" level="INFO">${established_peers_length} = 1</msg>
<status status="PASS" endtime="20181224 22:35:12.358" starttime="20181224 22:35:12.358"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.359" level="INFO">[u'1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:12.359" starttime="20181224 22:35:12.359"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.359" starttime="20181224 22:35:12.358"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:12.360" starttime="20181224 22:35:12.359"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.360" starttime="20181224 22:35:12.359"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.360" starttime="20181224 22:35:12.353"></status>
</kw>
<kw type="foritem" name="${cPeer} = 1.1.1.101">
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${cPeer}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.360" level="INFO">1.1.1.101</msg>
<status status="PASS" endtime="20181224 22:35:12.360" starttime="20181224 22:35:12.360"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>Peer State is ${current_peers['${cPeer}']['peerState']}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.361" level="INFO">Peer State is Established</msg>
<status status="PASS" endtime="20181224 22:35:12.361" starttime="20181224 22:35:12.360"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>Pass EVPN Test</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Pass EVPN Test" library="Validate_EVPN_Peerings">
<arguments>
<arg>${cPeer}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${peer} is Established</arg>
</arguments>
<msg timestamp="20181224 22:35:12.362" level="INFO">1.1.1.101 is Established</msg>
<status status="PASS" endtime="20181224 22:35:12.363" starttime="20181224 22:35:12.362"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.363" starttime="20181224 22:35:12.362"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.363" starttime="20181224 22:35:12.361"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.363" starttime="20181224 22:35:12.361"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' in @{target_peers} and '${current_peers['${cPeer}']['peerState']}'=='Established'</arg>
<arg>append to list</arg>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Append To List" library="Collections">
<doc>Adds ``values`` to the end of ``list``.</doc>
<arguments>
<arg>${established_peers}</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:12.364" starttime="20181224 22:35:12.364"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.364" starttime="20181224 22:35:12.363"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.364" starttime="20181224 22:35:12.363"></status>
</kw>
<kw name="Get Length" library="BuiltIn">
<doc>Returns and logs the length of the given item as an integer.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<assign>
<var>${established_peers_length}</var>
</assign>
<msg timestamp="20181224 22:35:12.364" level="INFO">Length is 2</msg>
<msg timestamp="20181224 22:35:12.365" level="INFO">${established_peers_length} = 2</msg>
<status status="PASS" endtime="20181224 22:35:12.365" starttime="20181224 22:35:12.364"></status>
</kw>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>${established_peers_length} != 0</arg>
<arg>Log</arg>
<arg>${established_peers}</arg>
</arguments>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.365" level="INFO">[u'1.1.1.102', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:12.365" starttime="20181224 22:35:12.365"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.365" starttime="20181224 22:35:12.365"></status>
</kw>
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${cPeer}' not in @{target_peers}</arg>
<arg>Fail Test Additional Peer</arg>
<arg>${cPeer}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:12.366" starttime="20181224 22:35:12.366"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.366" starttime="20181224 22:35:12.366"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.366" starttime="20181224 22:35:12.360"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.366" starttime="20181224 22:35:12.353"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${established_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.367" level="INFO">[u'1.1.1.102', u'1.1.1.101']</msg>
<status status="PASS" endtime="20181224 22:35:12.367" starttime="20181224 22:35:12.366"></status>
</kw>
<kw name="Log" library="BuiltIn">
<doc>Logs the given message with the given level.</doc>
<arguments>
<arg>${target_peers}</arg>
</arguments>
<msg timestamp="20181224 22:35:12.367" level="INFO">['1.1.1.101', '1.1.1.102']</msg>
<status status="PASS" endtime="20181224 22:35:12.367" starttime="20181224 22:35:12.367"></status>
</kw>
<kw type="for" name="${listObject} IN [ @{target_peers} ]">
<kw type="foritem" name="${listObject} = 1.1.1.101">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:12.368" starttime="20181224 22:35:12.368"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.368" starttime="20181224 22:35:12.367"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.368" starttime="20181224 22:35:12.367"></status>
</kw>
<kw type="foritem" name="${listObject} = 1.1.1.102">
<kw name="Run Keyword And Continue On Failure" library="BuiltIn">
<doc>Runs the keyword and continues execution even if a failure occurs.</doc>
<arguments>
<arg>Run Keyword If</arg>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<kw name="Run Keyword If" library="BuiltIn">
<doc>Runs the given keyword with the given arguments, if ``condition`` is true.</doc>
<arguments>
<arg>'${listObject}' not in @{established_peers}</arg>
<arg>Fail Test Peer List is Incomplete</arg>
<arg>${listObject}</arg>
</arguments>
<status status="PASS" endtime="20181224 22:35:12.369" starttime="20181224 22:35:12.369"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.369" starttime="20181224 22:35:12.368"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.369" starttime="20181224 22:35:12.368"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.369" starttime="20181224 22:35:12.367"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.369" starttime="20181224 22:35:12.351"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.369" starttime="20181224 22:35:12.351"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.369" starttime="20181224 22:35:11.328"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.369" starttime="20181224 22:35:11.326"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.369" starttime="20181224 22:35:08.206"></status>
</kw>
<doc>Validate EVPN Peerings for Leafs</doc>
<tags>
<tag>LEAF_EVPN</tag>
</tags>
<status status="PASS" endtime="20181224 22:35:12.369" critical="yes" starttime="20181224 22:35:08.205"></status>
</test>
<kw type="teardown" name="Clear All Connections" library="AristaLibrary">
<doc>Remove all connection objects from the cache and resets the list of
indexes.</doc>
<status status="PASS" endtime="20181224 22:35:12.371" starttime="20181224 22:35:12.370"></status>
</kw>
<status status="PASS" endtime="20181224 22:35:12.371" starttime="20181224 22:34:11.904"></status>
</suite>
<statistics>
<total>
<stat fail="0" pass="6">Critical Tests</stat>
<stat fail="0" pass="6">All Tests</stat>
</total>
<tag>
<stat fail="0" pass="1">LEAF_EVPN</stat>
<stat fail="0" pass="1">LEAF_OSPF</stat>
<stat fail="0" pass="1">LEAF_PING</stat>
<stat fail="0" pass="1">SPINE_EVPN</stat>
<stat fail="0" pass="1">SPINE_OSPF</stat>
<stat fail="0" pass="1">SPINE_PING</stat>
</tag>
<suite>
<stat fail="0" id="s1" name="L3FabricTest" pass="6">L3FabricTest</stat>
</suite>
</statistics>
<errors>
</errors>
</robot>
